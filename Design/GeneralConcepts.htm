<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>General Concepts</title>
</head>

<body>

<h2>Day 1</h2>
<p>General Concepts</p>
<p>It becomes clear looking at the layout that it is really more of a template 
for my own requirements and that the actual &quot;task item bar&quot; on the left as well 
as the specific fields for each task item should be completely user definable in 
terms of label, content, and control.&nbsp; </p>
<p>This pretty much means that we're looking at a NoSQL database structure with 
loose linkages between tasks and task items.&nbsp; The &quot;root&quot; of everything 
still remains the task, but the task items and their fields is really quite 
arbitrary.</p>
<p>So we need to be able to define the structure and its field content as one 
&quot;database&quot; of how the user wants to organize the information.</p>
<p>Certain fields end up being arrays (like URL links) that are represented 
discretely, while other fields (like notes) may be shows discretely as a 
scrollable collection of distinct textarea entries or more as a &quot;document&quot; where 
the user simply scrolls through a single textarea.</p>
<p>Searching - the user should be able to search on any field or a specific 
area, such as &quot;notes.&quot;&nbsp; </p>
<p>Any field can be either a singleton (like a date/time on a communication) or 
a collection, like a list of contacts for that communication.</p>
<p>So what we end up doing first is defining an arbitrary schema with enough 
metadata to describe the layout and controls of the fields in the schema as well 
as actions on schema elements, for example the task item bar can be represented 
as schema elements but they are buttons, not user input controls.</p>
<p>We don't want to go overboard with this!&nbsp; The complexity with this 
approach is that the page is not static -- the entire layout has to be generated 
from the metadata, so the question is, server-side generation or client-side?</p>
<p>Personally I prefer client-side.&nbsp; The server should be minimally 
involved with layout -- the server should serve content, as in data, not layout.&nbsp; 
This approach also facilitates development of the UI without needing a server 
and keeps all the UI code on the client rather than spreading it across both 
JavaScript and C# on the back-end.&nbsp; And no, I'm not interested in using 
node.js on the back-end.</p>
<h2>Day 2</h2>
<p>We should be able to have a fairly simple structures.&nbsp; Let's define a 
few, all of which are of course customizable but we'll define some useful 
defaults.</p>
<p>Status</p>
<p>I like to have a fairly specific status and get frustrated when I can't put 
that information in a simple dropdown that lets me see at a glance what's going 
on with the task.&nbsp; So, I like things like:</p>
<ul>
	<li>Todo</li>
	<li>Working on</li>
	<li>Testing</li>
	<li>QA</li>
	<li>Production (Completed)</li>
	<li>Waiting for 3rd Party</li>
	<li>Waiting for Coworker</li>
	<li>Waiting on Management</li>
	<li>Stuck</li>
</ul>
<p>Notice that I don't have a priority next to the task.&nbsp; I really don't 
give a sh*t about priorities -- there's usually a lot of things going on and I 
work on what I'm in the mood for and what I can work on.&nbsp; Of course, if you 
like priorities, you can add them to the UI.</p>
<p>Notice that I also don't categorize tasks into, for example, sprints, 
platforms, customers, etc.&nbsp; Again, if you want those things, you can add 
them.</p>
<p>What I do want is:</p>
<ol>
	<li>What is the task?</li>
	<li>What is its state?</li>
	<li>One line description of why it's in that state.</li>
</ol>
<p>So this is what I want to see (of course, what you want to see is going to be 
different):</p>
<p><img border="0" src="atask.png" width="442" height="62"></p>
<p>How would we define this layout in JSON so that you can create whatever needs 
your needs?&nbsp; Pretty much this means figuring out how to meet my needs 
first!</p>
<p>This might be the definition of the high level task list:</p>
<pre>[
  {
    Item:
    {
      Field: &quot;Task&quot;,
      Line: 0,
      Width: &quot;80%&quot;
    }
  },
  {
    Item:
    {
      Field: &quot;Status&quot;,
      SelectFrom: &quot;StatusList&quot;,
      OrderBy: &quot;StatusOrder&quot;,
      Line: 0,
      Width: &quot;20%&quot;
    }
  },
  {
    Item:
    {
      Field: &quot;Why&quot;,
      Line: 1,
      Width: &quot;100%&quot;
    }
  }
]</pre>
<p>These fields are all inline editable but we also want to support drilling 
into a field to view it's sub-records.&nbsp; Not all fields have sub-records 
(like Status), but this is determined by the metadata structure, so Status could 
have sub-records.&nbsp; Any time the user focuses on a control with 
sub-structures, the button bar will update and the &quot;show on select&quot; 
sub-structures will display the sub-records. </p>
<p>So we can define sub-structures, or allowable child records, like this using 
the Task entity as an example:</p>
<pre>[
  {Entity:&quot;Contact&quot;, Label:&quot;Contacts&quot;},
  {Entity:&quot;Link&quot;, Label:&quot;Links&quot;, &quot;ShowOnParentSelect&quot;: true},
  {Entity:&quot;KeyPoint&quot;, Label: &quot;Key Points&quot;},
  {Entity:&quot;Note&quot; Label: &quot;Notes&quot;, &quot;ShowOnParentSelect&quot;: true},
  {Entity:&quot;Communication&quot;, Label: &quot;Communications&quot;}
]</pre>
<p>Note that all sub-structures are defined in their singular form and we have 
complete flexibility as to the label used to represent the link.&nbsp; These 
&quot;show on parent select&quot; will always be visible unless the user collapses that 
section, and they are rendered in the order they appear in the list above.&nbsp; 
Where they render is determined by other layout information.</p>
<p>Other things to think about:</p>
<ul>
	<li>Sub-tasks (easy to do)</li>
	<li>Task dependencies</li>
</ul>
<h2>Day 3</h2>
<p>So, the more I think about this, the more I realize that this is really a 
very generalized entity creator/editor with not quite dynamic relationships, 
much as I've written about in my
<a href="https://www.codeproject.com/Articles/298818/Relationship-Oriented-Programming">
Relationship Oriented Programming</a> articles.&nbsp; So it seems natural that 
allowable relationships should be definable as well.&nbsp; But what I'd prefer 
to do at this point is some prototyping to get a sense of how some of these 
ideas can come to fruition.&nbsp; So let's start with the JSON above and write a 
function that turns it into an HTML template that can then be repeatedly applied 
as necessary.&nbsp; And at the same time, I'll be learning the nuances of 
TypeScript!</p>
<p>With some coding, I get this:</p>
<p><img border="0" src="prototype1.png" width="306" height="58"></p>
<p>Defined by the template array:</p>
<pre>let template = [ // Task Template
  {
    field: &quot;Task&quot;,
    line: 0,
    width: &quot;80%&quot;,
    control: &quot;textbox&quot;,
  },
  { 
    field: &quot;Status&quot;,
    selectFrom: &quot;StatusList&quot;,
    orderBy: &quot;StatusOrder&quot;,
    line: 0,
    width: &quot;20%&quot;,
    control: &quot;combobox&quot;,
  },
  {
    field: &quot;Why&quot;,
    line: 1,
    width: &quot;100%&quot;,
    control: &quot;textbox&quot;,
  }
];</pre>
<p>and the support of interfaces to define the template object model and a 
Builder class to put together the HTML:</p>
<pre>interface Item {
  field: string;
  line: number;
  width: string;
  control: string;
  selectedFrom?: string;
  orderBy?: string;
}

interface Items extends Array&lt;Item&gt; { }

class Builder {
  html: string;

  constructor() {
    this.html = &quot;&quot;;
  }

  public DivBegin(item: Item): Builder {
    this.html += &quot;&lt;div style='float:left; width:&quot; + item.width + &quot;'&gt;&quot;;

    return this;
  }

  public DivEnd(): Builder {
    this.html += &quot;&lt;/div&gt;&quot;;

    return this;
  }

  public DivClear(): Builder {
    this.html += &quot;&lt;div style='clear:both'&gt;&lt;/div&gt;&quot;;

    return this;
  }

  public TextInput(item: Item): Builder {
    let placeholder = item.field;
    this.html += &quot;&lt;input type='text' placeholder='&quot; + placeholder + &quot;' style='width:100%'&gt;&quot;;

    return this;
  }

  public Combobox(item: Item): Builder {
    this.SelectBegin().Option(&quot;A&quot;).Option(&quot;B&quot;).Option(&quot;C&quot;).SelectEnd();

    return this;
  }

  public SelectBegin(): Builder {
    this.html += &quot;&lt;select style='width:100%; height:21px'&gt;&quot;;

    return this;
  }

  public SelectEnd(): Builder {
    this.html += &quot;&lt;/select&gt;&quot;;

    return this;
  }

  public Option(text: string, value?: string): Builder {
    this.html += &quot;&lt;option value='&quot; + value + &quot;'&gt;&quot; + text + &quot;&lt;/option&gt;&quot;;

    return this;
  }
}</pre>
<p>This leaves only the logic for constructing the template:</p>
<pre>private CreateHtmlTemplate(template: Items) : string {
  let builder = new Builder();
  let line = -1;
  let firstLine = true;

  template.forEach(item =&gt; {
    if (item.line != line) {
      line = item.line;

      if (!firstLine) {
        builder.DivClear();
      }

      firstLine = false;
    }

    builder.DivBegin(item);

    switch (item.control) {
      case &quot;textbox&quot;:
        builder.TextInput(item);
        break;

      case &quot;combobox&quot;:
        builder.Combobox(item);
        break;
      }

    builder.DivEnd();
  });

  builder.DivClear();

  return builder.html;
}</pre>
<p>So the top-level code just does this:</p>
<pre>let html = this.CreateHtmlTemplate(template);
jQuery(&quot;#template&quot;).html(html);</pre>
<p>If I chain the template:</p>
<pre>jQuery(&quot;#template&quot;).html(html + html + html);</pre>
<p>I get:</p>
<p><img border="0" src="prototype2.png" width="307" height="141"></p>
<p>Cool.&nbsp; May not be the prettiest thing, but the basics are what I'm 
looking for.</p>
<p>Now personally what bugs me to no end is that the template object reminds me 
of ExtJs: basically a collection of arbitrary keys to define the layout of the 
UI.&nbsp; Maybe it's unavoidable, and I certainly am not going down the route 
that ExtJs uses which is to create custom ID's that change every time the page 
is refreshed.&nbsp; Talk about killing the ability to do test automation at the 
UI level.&nbsp; It is ironic though, in writing something like this, I begin to 
actually have a better understanding of the design decisions that ExtJs made.</p>
<p>Which brings us to how the comboboxes are actually populated.&nbsp; So yeah, 
there's a concept of a &quot;store&quot; in ExtJs, and manipulating the store 
automatically (or that's the theory) updates the UI.&nbsp; That's too much for 
me right now, but I do want the ability to use an existing object or fetch (and 
potentially cache) the object from a REST call.&nbsp; So let's put something 
simple together.&nbsp; Here's my states:</p>
<pre>let taskStates = [
  { text: 'TODO'},
  { text: 'Working On' },
  { text: 'Testing' },
  { text: 'QA' },
  { text: 'Done' },
  { text: 'On Production' },
  { text: 'Waiting on 3rd Party' },
  { text: 'Waiting on Coworker' },
  { text: 'Waiting on Management' },
  { text: 'Stuck' },
];</pre>
<p>With a little refactoring:</p>
<pre>export interface Item {
  field: string;
  line: number;
  width: string;
  control: string;
  storeName?: string;  // &lt;== this got changed to &quot;storeName&quot;
  orderBy?: string;
}</pre>
<p>and the prototype concept of a store:</p>
<pre>interface KeyStoreMap {
  [key: string] : any;  // Eventually &quot;any&quot; will be replaced with a more formal structure.
}

export class Store {
  stores: KeyStoreMap = {};

  public AddLocalStore(key: string, store: any) {
  this.stores[key] = store;
  }

  // Eventually will support local stores, REST calls, caching, computational stores, and using other 
  // existing objects as stores.
  public GetStore(key: string) {
    return this.stores[key];
  }
}</pre>
<p>I now do this:</p>
<pre>let store = new Store();
store.AddLocalStore(&quot;StatusList&quot;, taskStates);
let html = this.CreateHtmlTemplate(template, store);</pre>
<p>and the template builder does this:</p>
<pre>public Combobox(item: Item, store: Store) : TemplateBuilder {
  this.SelectBegin();

  store.GetStore(item.storeName).forEach(kv =&gt; {
    this.Option(kv.text);
  });

  this.SelectEnd();

  return this;
}</pre>
<p>Resulting in:</p>
<p><img border="0" src="stores1.png" width="445" height="284"></p>
<p>That was easy enough.</p>
<p>So what's involved with persisting the actual task data and restoring it?&nbsp; 
Seems like the store concept can be extended to save state, and one of the 
states I want to support is <code>localStorage</code>.&nbsp; This also seems 
complicated as I'm already dealing with an array of objects!&nbsp; And again, I 
realize why in ExtJS stores are always arrays of things, even if the store 
represents a singleton -- because it's easier!&nbsp; So let's refactor the <code>Store</code> 
class.&nbsp; First, we want something that defines the store types, like 
this:</p>
<pre>export enum StoreType {
  Undefined,
  InMemory,
  LocalStorage,
  RestCall,
}
</pre>
<p>And then we want something that manages the configuration of the store:</p>
<pre>import { StoreType } from &quot;../enums/StoreType&quot;

export class StoreConfiguration {
  storeType: StoreType;
  cached: boolean;
  data: any;

  constructor() {
    this.storeType = StoreType.Undefined;
    this.data = [];
  }
}</pre>
<p>And finally, we'll refactor the Store class so it looks like this:</p>
<pre>import { StoreConfiguration } from &quot;./StoreConfiguration&quot;
import { StoreType } from &quot;../enums/StoreType&quot;
import { KeyStoreMap } from &quot;../interfaces/KeyStoreMap&quot;

export class Store {
  stores: KeyStoreMap = {};

  public CreateStore(key: string, type: StoreType) {
    this.stores[key] = new StoreConfiguration();
  }

  public AddInMemoryStore(key: string, data: object[]) {
    let store = new StoreConfiguration();
    store.storeType = StoreType.InMemory;
    store.data = data;
    this.stores[key] = store;
  }

  // Eventually will support local stores, REST calls, caching, computational stores, and using other 
  // existing objects as stores.
  public GetStoreData(key: string) {
    return this.stores[key].data;
  }
}</pre>
<p>which is used like this:</p>
<pre>let store = new Store();
store.AddInMemoryStore(&quot;StatusList&quot;, taskStates);
store.CreateStore(&quot;Tasks&quot;, StoreType.LocalStorage);</pre>
<p>Next, the template that we created earlier:</p>
<pre>let html = this.CreateHtmlTemplate(template, store);</pre>
<p>Needs to know what store to use for the template items, so we do this 
instead:</p>
<pre>let html = this.CreateHtmlTemplate(template, store, &quot;Tasks&quot;);</pre>
<p>Frankly, I have no idea whether this is a good idea or not, but let's go for 
it for now and see how it holds up.</p>
<p>Next we need to refactor this code <code>jQuery("#template").html(html + html + html); </code>so that we're not blindly copying the HTML 
template but instead we have a way of building the template so that it knows 
what object index in the store's data to update when the field changes.&nbsp; 
Dealing with decoupling sorting from the store's representation of the data will 
be an interesting thing to figure out.&nbsp; Later.&nbsp; More to the point, 
that particular line of code will probably be tossed completely when we 
implement loading the tasks from <code>localStorage</code>.&nbsp; For the 
moment, in the template builder, let's add a custom attribute <code>storeIdx</code> 
to our two controls:</p>
<pre>this.html += &quot;&lt;input type='text' placeholder='&quot; + placeholder + &quot;' style='width:100%' storeIdx='{idx}'&gt;&quot;;</pre>
<p>and:</p>
<pre>this.html += &quot;&lt;select style='width:100%; height:21px' storeIdx='{idx}'&gt;&quot;;</pre>
<p>And now we do this:</p>
<pre>let html = this.CreateHtmlTemplate(template, store, &quot;Tasks&quot;);
let task1 = this.SetStoreIndex(html, 0);
let task2 = this.SetStoreIndex(html, 1);
let task3 = this.SetStoreIndex(html, 2);
jQuery(&quot;#template&quot;).html(task1 + task2 + task3);</pre>
<p>with a little help from:</p>
<pre>private SetStoreIndex(html: string, idx: number) : string {
  // a &quot;replace all&quot; function.
  let newHtml = html.split(&quot;{idx}&quot;).join(idx.toString());

  return newHtml;
}</pre>
<p>and lo-and-behold, we have indices now to the store, for example:</p>
<p><img border="0" src="stores2.png" width="503" height="51"></p>
<p>Sigh.&nbsp; Note that the resulting HTML has the <code>storeIdx</code> attribute as all 
lowercase.&nbsp; This seems to be a jQuery thing that I'll investigate later.&nbsp; 
Next, we need to create <code>onchange</code> handlers for updating the store 
when the value changes.&nbsp; This must be done with &quot;late binding&quot; because the 
HTML is created dynamically from a template.&nbsp; Again I see why ExtJS ends up 
assigning arbitrary ID's to elements -- how do we identify the element to which 
to bind the <code>onchange</code> handler?&nbsp; Personally I prefer using a 
separate attribute to uniquely identify the binding point, and probably a GUID 
for the attribute value.&nbsp; Who knows what that will do to performance if 
there's hundreds of elements that must be bound, but honestly, I'm not going to 
worry about that!</p>
<p>It's 10:30 PM, I'm calling it a night!</p>
<h2>Day 4</h2>
<p>So here we are with the task of implementing late binding.&nbsp; First, a 
couple refactorings to the template builder to set up the <code>bindGuid</code> attribute 
with a unique identifier which we'll use to determine the binding, again using 
the <code>input</code> and <code>select</code> elements as examples:</p>
<pre>public TextInput(item: Item, entityStore: StoreConfiguration) : TemplateBuilder {
  let placeholder = item.field;
  let guid = Guid.NewGuid();
  this.html += &quot;&lt;input type='text' placeholder='&quot; + placeholder + &quot;' style='width:100%' storeIdx='{idx}' bindGuid='&quot; + guid.ToString() + &quot;'&gt;&quot;;
  let el = new TemplateElement(item, guid);
  this.elements.push(el);

 return this;
}

public SelectBegin(item: Item) : TemplateBuilder {
  let guid = Guid.NewGuid();
  this.html += &quot;&lt;select style='width:100%; height:21px' storeIdx='{idx}' bindGuid='&quot; + guid.ToString() + &quot;'&gt;&quot;;
  let el = new TemplateElement(item, guid);
  this.elements.push(el);

  return this;
}</pre>
<p>These all get put into an array:</p>
<pre>elements: TemplateElement[] = [];</pre>
<p>which the binding process on the document being ready wires up:</p>
<pre>jQuery(document).ready(() =&gt; {
  // Bind the onchange events.
  builder.elements.forEach(el =&gt; {
    let jels = jQuery(&quot;[bindGuid = '&quot; + el.guid.ToString() + &quot;']&quot;);

    jels.each((_, elx) =&gt; {
      let jel = jQuery(elx);

      jel.on('change', () =&gt; {
        let recIdx = jel.attr(&quot;storeIdx&quot;);
        console.log(&quot;change for &quot; + el.guid.ToString() + &quot; at index &quot; + recIdx + &quot; value of &quot; + jel.val());
        taskStore.SetProperty(Number(recIdx), el.item.field, jel.val());
      });
    });
  });
});</pre>
<p>There's a &quot;not good&quot; piece of code in the above snippet: 
<code>taskStore.SetProperty</code>.&nbsp; The hard-wiring to the <code>taskStore</code> is refactored out 
later so the binding is not specific to just the Task store!</p>
<p>Notice here we also use the record index to qualify the record.&nbsp; We do 
this because with this code <code>jQuery("#template").html(task1 + task2 + task3);</code> there 
are multiple elements with the same GUID because we've cloned the HTML template 
three times.&nbsp; Probably not ideal but I'll live with that for now.&nbsp; In 
the meantime, the store I've created for the tasks:</p>
<pre>let taskStore = store.CreateStore("Tasks", StoreType.LocalStorage);</pre>
<p>manages setting the property value for the record at the specified index, and 
creating empty records as necessary:</p>
<pre>public SetProperty(idx: number, property: string, value: any): StoreConfiguration {
  // Create additional records as necessary:
  while (this.data.length - 1 &lt; idx) {
    this.data.push({});
  }

  this.data[idx][property] = value;
  this.UpdatePhysicalStorage(this.data[idx], property, value);

  return this;
}

private UpdatePhysicalStorage(record: any, property: string, value: string) : Store {
  switch (this.storeType) {
    case StoreType.InMemory:
      // Do nothing.
      break;

    case StoreType.RestCall:
      // Eventually send an update but we probably ought to have a PK with which to associate the change.
      break;

    case StoreType.LocalStorage:
      // Here we just update the whole structure.
      let json = JSON.stringify(this.data);
      window.localStorage.setItem(this.name, json);
      break;	
  }

  return this;
}</pre>
<p>At the moment this is implemented in the <code>StoreConfiguration</code> class.&nbsp; 
Seems awkward yet it's the <code>StoreConfiguration</code> class that maintains the data, 
whereas the <code>Store</code> class is really a &quot;store manager&quot;, so probably <code>Store</code> should be 
called <code>StoreManager</code> and <code>StoreConfiguration</code> should be called <code>Store</code>!&nbsp; 
Gotta love refactoring to make the names of things clearer.&nbsp; So from 
hereon, that's what they'll be called.&nbsp; Rather a PITA to do without the 
&quot;rename&quot; feature when working with C# code!</p>
<p>After entering some values:</p>
<p><img border="0" src="localstore2.png" width="554" height="138"></p>
<p>we can see that these have been serialized to the local storage (inspecting 
local storage in Chrome):</p>
<p><img border="0" src="localstore1.png" width="795" height="260"></p>
<p>Cool, however notice that record 0 does not have a status, as I didn't change 
it from the default.&nbsp; What to do about that?&nbsp; This isn't an easy 
problem because we have a disconnect between the number of template instances 
we've created and the store data.&nbsp; So we need a mechanism to deal with that 
and set defaults.&nbsp; The simplest answer is to brute force that right now.&nbsp; 
At least it's explicit:</p>
<pre>taskStore.SetProperty(0, &quot;Status&quot;, taskStates[0].text);
taskStore.SetProperty(1, &quot;Status&quot;, taskStates[0].text);
taskStore.SetProperty(2, &quot;Status&quot;, taskStates[0].text);</pre>
<p>So now the task store is initialized with defaults:</p>
<p><img border="0" src="localstore3.png" width="377" height="72"></p>
<p>Ultimately this only pushed the problem into the &quot;ignored&quot; bucket, as it's 
also dependent on the order of the status array.&nbsp; But no matter, let's push 
on and now that we have something in the store, let's load the UI with the store 
data!&nbsp; We also have the question of whether the store should be updated per keypress 
or only when the <code>onchange</code> event fires, which occurs when the element loses 
focus.&nbsp; Another &quot;ignore for now&quot; issue.&nbsp; Furthermore, we 
have an excellent demonstration of &quot;don't implement code with side-effects!&quot; in 
this function:</p>
<pre>public SetProperty(idx: number, property: string, value: any): Store {
  // Create additional records as necessary:
  while (this.data.length - 1 &lt; idx) {
    this.data.push({});
  }

  this.data[idx][property] = value;
  this.UpdatePhysicalStorage(this.data[idx], property, value);

  return this;
}</pre>
<p>As updating the physical storage in the case of the local storage obliterates 
anything we've saved!&nbsp; I've created a bit of a conundrum -- if the records 
don't exist in the local storage, I want to set the defaults, but if they do 
exist, I don't want to set the defaults!&nbsp; So first, let's get rid of the 
side-effect and move the updating of the physical storage to the onchange 
handler:</p>
<pre>jel.on('change', () =&gt; {
  let recIdx = Number(jel.attr(&quot;storeIdx&quot;));
  let field = el.item.field;
  let val = jel.val();

  console.log(&quot;change for &quot; + el.guid.ToString() + &quot; at index &quot; + recIdx + &quot; value of &quot; + jel.val());
  taskStore.SetProperty(recIdx, field, val).UpdatePhysicalStorage(recIdx, field, val);
});</pre>
<p>Next, this gets removed:</p>
<pre>taskStore.SetProperty(0, &quot;Status&quot;, taskStates[0].text);
taskStore.SetProperty(1, &quot;Status&quot;, taskStates[0].text);
taskStore.SetProperty(2, &quot;Status&quot;, taskStates[0].text);</pre>
<p>and instead is replaced with the ability to set a default value if it doesn't 
exist, <i>after</i> the store has been loaded:</p>
<pre>taskStore.Load()
  .SetDefault(0, &quot;Status&quot;, taskStates[0].text)
  .SetDefault(1, &quot;Status&quot;, taskStates[0].text)
  .SetDefault(2, &quot;Status&quot;, taskStates[0].text)
  .Save();</pre>
<p>which is implemented as:</p>
<pre>public SetDefault(idx: number, property: string, value: any): Store {
  this.CreateNecessaryRecords(idx);

  if (!this.data[idx][property]) {
    this.data[idx][property] = value;
  }

  return this;
}</pre>
<p>And the <code>Save</code> function:</p>
<pre>public Save(): Store {
  switch (this.storeType) {
    case StoreType.InMemory:
      // TODO: throw exception?
      break;

    case StoreType.RestCall:
      // Eventually send an update but we probably ought to have a PK with which to associate the change.
      break;

    case StoreType.LocalStorage:
      // Here we just update the whole structure.
      this.SaveToLocalStorage();
      break;
  }

  return this;
}</pre>
<p>However, this has the annoying effect of potentially making REST calls to 
save each record, even if nothing changed.&nbsp; Another &quot;ignore this for now&quot; 
issue, but we'll definitely need to implement a &quot;field dirty&quot; flag!&nbsp; For 
local storage, we have no choice, the entire structure must be saved, so for now 
we're good to go.&nbsp; When there's no local storage, we get the desired 
defaults:</p>
<p><img border="0" src="localstore4.png" width="376" height="69"></p>
<p>And when there is data, it's not obliterated by refreshing the page:</p>
<p><img border="0" src="localstore5.png" width="435" height="72"></p>
<p>Of course the UI doesn't update because we need the binding to work the other 
way as well!&nbsp; A brute force implementation looks like this:</p>
<pre>for (let i = 0; i &lt; 3; i++) {
  for (let j = 0; j &lt; builder.elements.length; j++) {
    let tel = builder.elements[j];
    let guid = tel.guid.ToString();
    let jel = jQuery(`[bindGuid = '${guid}'][storeIdx = '${i}']`);
    jel.val(taskStore.GetProperty(i, tel.item.field));
  }
}</pre>
<p>Oooh, notice the 
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">template literal</a>: <code>let jel = jQuery(`[bindGuid = '${guid}'][storeIdx = '${i}']`);</code> -- I'll have to refactor the code and use that more often!</p>
<p>This yields on page load:</p>
<p><img border="0" src="localstore6.png" width="554" height="136"></p>
<p>Cool, I can now create and save three tasks!&nbsp; Calling it quits for Day 4, back 
soon to work on reverse binding and better handling of defaults as well as 
getting rid of this silly &quot;3 tasks&quot; thing and making tasks more dynamic.</p>
<h2>Day 5</h2>
<p>So that brute force approach above needs to be fixed, but I don't want the 
store to know anything about how the records fields map to UI elements, so I 
think what I'd like to do is provide callbacks for record and property level 
updates using the good ol' Inversion of Control principle.&nbsp; Possibly 
something like this should be done for the different store types as well so the 
application can override behavior per store.&nbsp; Later.</p>
<p>To the Store class I'll add a couple callbacks with default &quot;do nothing&quot; 
handlers:</p>
<pre>recordChangedCallback: (idx: number, record: any, store: Store) =&gt; void = () =&gt; { }; 
propertyChangedCallback: (idx: number, field: string, value: any, store: Store) =&gt; void = () =&gt; { };</pre>
<p>and in the <code>Load</code> function, we'll call the <code>recordChangedCallback</code> for every 
record loaded (probably not what we want to do in the long run!):</p>
<pre>this.data.forEach((record, idx) =&gt; this.recordChangedCallback(idx, record, this));</pre>
<p>This gets wired in to the taskStore -- notice it's implemented so that it 
passes in the template builder, which is sort of like a view, so we can acquire 
all the field definitions in the &quot;view&quot; template:</p>
<pre>taskStore.recordChangedCallback = (idx, record, store) =&gt; this.UpdateRecordView(builder, store, idx, record);</pre>
<p>and the handler looks a lot like the brute force approach above.</p>
<pre>private UpdateRecordView(builder: TemplateBuilder, store: Store, idx: number, record: any): void {
  for (let j = 0; j &lt; builder.elements.length; j++) {
    let tel = builder.elements[j];
    let guid = tel.guid.ToString();
    let jel = jQuery(`[bindGuid = '${guid}'][storeIdx = '${idx}']`);
    let val = store.GetProperty(idx, tel.item.field);
    jel.val(val);
  }
}</pre>
<p>This is a fairly generic approach.&nbsp; Let's do something similar for 
changing just a property and testing that by setting a record's property value 
via the store:</p>
<pre>public SetProperty(idx: number, field: string, value: any): Store {
  this.CreateNecessaryRecords(idx);
  this.data[idx][field] = value;
  this.propertyChangedCallback(idx, field, value, this);  // &lt;== this got added.

  return this;
}</pre>
<p>Wired up like this:</p>
<pre>taskStore.propertyChangedCallback = (idx, field, value, store) =&gt; this.UpdatePropertyView(builder, store, idx, field, value);</pre>
<p>And implemented like this:</p>
<pre>private UpdatePropertyView(builder: TemplateBuilder, store: Store, idx: number, field: string, value: any): void {
  let tel = builder.elements.find(e =&gt; e.item.field == field);
  let guid = tel.guid.ToString();
  let jel = jQuery(`[bindGuid = '${guid}'][storeIdx = '${idx}']`);
  jel.val(value);
}</pre>
<p>Now we can set a property for a record in a store and it's reflected in the 
UI:</p>
<pre>taskStore.SetProperty(1, &quot;Task&quot;, `Random Task #${Math.floor(Math.random() * 100)}`);</pre>
<p><img border="0" src="setProperty1.png" width="499" height="137"></p>
<p>So let's look at adding and deleting tasks.&nbsp; Some of you are either 
laughing or groaning because I've backed myself into another corner with this 
&quot;record index&quot; concept, which makes deleting and inserting tasks a total 
nightmare because the <code>storeIdx</code> will go out of sync with the record it's 
managing.&nbsp; So it's time to throw out this whole concept in favor of a 
smarter way to handle records.&nbsp; At the moment I've declared the store's 
data as an array of name:value pairs:</p>
<pre>data: {}[] = [];</pre>
<p>but it's time for something smarter -- a way to uniquely identify a record 
without using a row index, and a way to get that unique identifier associated 
with the UI elements.&nbsp; The irony here is that a numeric index is a fine way 
to do this, we just need to map the index to the physical record rather than 
assume a 1:1 correlation.&nbsp; We also no longer need the 
<code>CreateNecessaryRecords</code> method but instead we create only this 
single stub key:value object if the &quot;index&quot; is missing in the index-record map.</p>
<p>So instead, I now have:</p>
<pre>private data: RowRecordMap = {};</pre>
<p>It's private because I don't want anyone touching this structure, which is 
declared like this:</p>
<pre>export interface RowRecordMap {
  [key: number]: {}
}</pre>
<p>The most significant refactoring involved the record change callback:</p>
<pre>jQuery.each(this.data, (k, v) =&gt; this.recordChangedCallback(k, v, this));</pre>
<p>Pretty much nothing else changes because instead of the index being an array 
index, it's now a dictionary key and is therefore used in the same way.&nbsp; 
Here we assume that on an initial load, the record index (from 0 to n-1) 
corresponds 1:1 with the indices created by the template builder.&nbsp; One 
other important change is that to save to local storage, we don't want to save 
the key:value model, just the values, as the keys (the row index lookup) is 
completely arbitrary:</p>
<pre>public GetRawData(): {}[] {
  return jQuery.map(this.data, value =&gt; value);
}

private SaveToLocalStorage() {
  let json = JSON.stringify(this.GetRawData());
  window.localStorage.setItem(this.storeName, json);
}</pre>
<h3>Deleting a Task</h3>
<p>More refactoring!&nbsp; To make this work, each template that we're cloning 
needs to be wrapped in its own div so we can remove it.&nbsp; Currently the HTML 
looks like this:</p>
<p><img border="0" src="delete1.png" width="399" height="326"></p>
<p>Where the red box is one template instance.&nbsp; Instead, we want this (the 
code change to make this work was trivial so I'm not going to show it):</p>
<p><img border="0" src="delete2.png" width="403" height="211"></p>
<p>Now let's reduce the width of the &quot;Why&quot; textbox and add a &quot;Delete&quot; button to 
the template definition:</p>
<pre>{
  field: &quot;Why&quot;,
  line: 1,
  width: &quot;80%&quot;,			// &lt;== Changed
  control: &quot;textbox&quot;,
},
{
  text: &quot;Delete&quot;,		// &lt;== Added all this
  line: 1,
  width: &quot;20%&quot;,
  control: &quot;button&quot;,
}</pre>
<p>And adding a Button method to the TemplateBuilder:</p>
<pre>public Button(item: Item): TemplateBuilder {
  let guid = Guid.NewGuid();
  this.html += `&lt;button type='button' style='width:100%' storeIdx='{idx}' bindGuid='${guid.ToString()}&gt;${item.text}&lt;/button&gt;`;
  let el = new TemplateElement(item, guid);
  this.elements.push(el);

  return this;
}</pre>
<p>We get this:</p>
<p><img border="0" src="delete3.png" width="583" height="136"></p>
<p>Snazzy.&nbsp; Now we have to wire up the event!&nbsp; Uh, ok, how will this 
work?&nbsp; Well first, we need to wire up the click event:</p>
<pre>switch (el.item.control) {
  case &quot;button&quot;:
    jel.on('click', () =&gt; {
      let recIdx = Number(jel.attr(&quot;storeIdx&quot;));
      console.log(`click for ${el.guid.ToString()} at index ${recIdx}`);
    });
    break;

  case &quot;textbox&quot;:
  case &quot;combobox&quot;:
    jel.on('change', () =&gt; {
      let recIdx = Number(jel.attr(&quot;storeIdx&quot;));
      let field = el.item.field;
      let val = jel.val();

      console.log(`change for ${el.guid.ToString()} at index ${recIdx} with new value of ${jel.val()}`);
      storeManager.GetStore(el.item.associatedStoreName).SetProperty(recIdx, field, val).UpdatePhysicalStorage(recIdx, field, val);
    });
    break;
}</pre>
<p>And we can verify that it works by looking at the console log:</p>
<p><img border="0" src="delete4.png" width="507" height="79"></p>
<h3>Event Router</h3>
<p>Given that this is all constructed by metadata, we need an event router which 
can route events to arbitrary but predefined functions in the code.&nbsp; This 
should be quite flexible but only if the code supports the behaviors we need.</p>
<p>So let's add a route property to the template:</p>
<pre>{
  text: &quot;Delete&quot;,
  line: 1,
  width: &quot;20%&quot;,
  control: &quot;button&quot;,
  route: &quot;DeleteRecord&quot;,
}</pre>
<p>Note that I don't call the route &quot;deleteTask&quot;, because deleting a record 
should be handled in a very general purpose manner.&nbsp; The event router start 
of very simple:</p>
<pre>import { Store } from &quot;../classes/Store&quot;
import { RouteHandlerMap } from &quot;../interfaces/RouteHandlerMap&quot;

export class EventRouter {
  routes: RouteHandlerMap = {};

  public AddRoute(routeName: string, fnc: (store: Store, idx: number) =&gt; void) {
    this.routes[routeName] = fnc;
  }

  public Route(routeName: string, store: Store, idx: number): void {
    this.routes[routeName](store, idx);
  }
}</pre>
<p>The delete record handler is initialized:</p>
<pre>let eventRouter = new EventRouter();
eventRouter.AddRoute(&quot;DeleteRecord&quot;, (store, idx) =&gt; store.DeleteRecord(idx));</pre>
<p>A callback and the DeleteRecord function is added to the store:</p>
<pre>recordDeletedCallback: (idx: number, store: Store) =&gt; void = () =&gt; { }; 
...
public DeleteRecord(idx: number) : void {
  delete this.data[idx];
  this.recordDeletedCallback(idx, this);
}</pre>
<p>The delete record callback is initialized:</p>
<pre>taskStore.recordDeletedCallback = (idx, store) =&gt; {
  this.DeleteRecordView(builder, store, idx);
  store.Save();
}</pre>
<p>The router is invoked when the button is clicked:</p>
<pre>case &quot;button&quot;:
  jel.on('click', () =&gt; {
    let recIdx = Number(jel.attr(&quot;storeIdx&quot;));
    console.log(`click for ${el.guid.ToString()} at index ${recIdx}`);
    eventRouter.Route(el.item.route, storeManager.GetStore(el.item.associatedStoreName), recIdx);
  });
break;</pre>
<p>and the div wrapping the record is removed:</p>
<pre>private DeleteRecordView(builder: TemplateBuilder, store: Store, idx: number): void {
  jQuery(`[templateIdx = '${idx}']`).remove();
}</pre>
<p>Ignoring:</p>
<ul>
	<li>The &quot;templateIdx&quot; attribute name for now, which obviously has to be 
	specified somehow to support more than one template entity type.</li>
	<li>That this removes the entire div as opposed to, say, clearing the fields 
	or removing a row from a grid, this works nicely.&nbsp; </li>
<li>That the Save call doesn't have a clue as to how to send a REST call to 
delete the specific record.</li>
</ul>
<p>We can mosey on along and after clicking on the delete button for second 
task, T2, we now see:</p>
<p><img border="0" src="delete5.png" width="555" height="99"></p>
<p>and our local storage looks like this:</p>
<p><img border="0" src="delete6.png" width="410" height="59"></p>
<p>Now let's refactor the load process so that the callback dynamically creates 
the template instances, which will be a precursor to inserting a new task.&nbsp; 
First, the <code>recordCreatedCallback</code> is renamed to <code>recordCreatedCallback</code>, which is a 
much better name!&nbsp; Then we're going to remove this prototyping code:</p>
<pre>let task1 = this.SetStoreIndex(html, 0);
let task2 = this.SetStoreIndex(html, 1);
let task3 = this.SetStoreIndex(html, 2);
jQuery(&quot;#template&quot;).html(task1 + task2 + task3);</pre>
<p>because our template &quot;view&quot; is going to be created dynamically as records are 
loaded.&nbsp; So now the <code>CreateRecordView</code> function looks like this:</p>
<pre>private CreateRecordView(builder: TemplateBuilder, store: Store, idx: number, record: {}): void {
  let html = builder.html;
  let template = this.SetStoreIndex(html, idx);
  jQuery(&quot;#template&quot;).append(template);

  for (let j = 0; j &lt; builder.elements.length; j++) {
    let tel = builder.elements[j];
    let guid = tel.guid.ToString();
    let jel = jQuery(`[bindGuid = '${guid}'][storeIdx = '${idx}']`);
    let val = record[tel.item.field];
    jel.val(val);
  }
}</pre>
<h3>Inserting Tasks</h3>
<p>And because in testing I obliterated all my tasks, I now have to implement a 
Create Task button!&nbsp; The events for all elements in the template will also 
need to be wired up every time we create a task!&nbsp; First, the HTML:</p>
<pre>&lt;button type=&quot;button&quot; id=&quot;createTask&quot;&gt;Create Task&lt;/button&gt;
&lt;div id=&quot;template&quot; style=&quot;width:40%&quot;&gt;&lt;/div&gt;</pre>
<p>Then wiring up the event partly using the event router:</p>
<pre>jQuery(&quot;#createTask&quot;).on('click', () =&gt; {
  let idx = eventRouter.Route(&quot;CreateRecord&quot;, taskStore, 0); // insert at position 0
  taskStore.SetDefault(idx, &quot;Status&quot;, taskStates[0].text);
  taskStore.Save();
});</pre>
<p>and the route definition:</p>
<pre>eventRouter.AddRoute(&quot;CreateRecord&quot;, (store, idx) =&gt; store.CreateRecord(true));</pre>
<p>and the implementation in the store:</p>
<pre>public CreateRecord(insert = false): number {
  let nextIdx = 0;

  if (this.Records() &gt; 0) {
    nextIdx = Math.max.apply(Math, Object.keys(this.data)) + 1;
  }

  this.data[nextIdx] = {};
  this.recordCreatedCallback(nextIdx, {}, insert, this);

  return nextIdx;
}</pre>
<p>Notice how we obtain a &quot;unique&quot; record &quot;index&quot;, and how we can specify 
whether to insert at the beginning or append to the end, not of the data records 
(these are order independent) but the flag gets passed on to the &quot;view&quot; that 
handles where the template should be created, so once again we refactor 
<code>CreateRecordView</code>:</p>
<pre>private CreateRecordView(builder: TemplateBuilder, store: Store, idx: number, record: {}, insert: boolean): void {
  let html = builder.html;
  let template = this.SetStoreIndex(html, idx);

  if (insert) {
    jQuery(&quot;#template&quot;).prepend(template);
  } else {
    jQuery(&quot;#template&quot;).append(template);
  }

  this.BindSpecificRecord(builder, idx);

  for (let j = 0; j &lt; builder.elements.length; j++) {
    let tel = builder.elements[j];
    let guid = tel.guid.ToString();
    let jel = jQuery(`[bindGuid = '${guid}'][storeIdx = '${idx}']`);
    let val = record[tel.item.field];
    jel.val(val);
  }
}</pre>
<p>I'm not going to show you the BindSpecificRecord function because it's almost 
identical to the binding that occurs in the document ready event, and so all 
that common code needs to be refactored before I show it to you!&nbsp; One odd 
behavior that I'm saving for the next day is that when the template is created 
this way, the combobox doesn't default to &quot;TODO&quot; - will have to figure out why.&nbsp; 
Regardless, starting from a blank slate:</p>
<p><img border="0" src="insert1.png" width="101" height="33"></p>
<p>I created to tasks, note how they are in reverse order because tasks are <i>
prepended</i> in the UI:</p>
<p><img border="0" src="insert2.png" width="552" height="119"></p>
<p>and we can see that they are <i>appended</i> in the local storage:</p>
<p><img border="0" src="insert3.png" width="569" height="55"></p>
<p>This of course causes a problem when the page is refreshed:</p>
<p><img border="0" src="insert4.png" width="551" height="114"></p>
<p>The order got changed!&nbsp; Hmmm...</p>
<p>Now, from demos I've seen of Vue and other frameworks, doing what has taken 5 
days to accomplish here is probably a 30 minute exercise in Vue.&nbsp; However, 
the point here is that I'm actually building the framework and the application 
together, and quite frankly, having a lot of fun doing it!&nbsp; So that's all 
that counts! End of Day 5, and I can finally create, edit, and delete tasks!</p>
<h2>Day 6</h2>
<p>So this is one of those &quot;rubber meets the road&quot; moments.&nbsp; I'm going to 
add a couple relationships.&nbsp; Software is not monogamous!&nbsp; I'd like to 
add contacts and notes that are child entities of the task.&nbsp; My &quot;tasks&quot; are 
usually integration level tasks (they probably should be called projects instead 
of tasks!), like &quot;add this credit card processor&quot;, which 
means that I have a bunch of people that I'm talking to, and I want to be able 
to find them as related to the task.&nbsp; Same with notes, I want to make notes 
of conversations, discoveries and so forth related to the task.&nbsp; Why this 
will be a &quot;rubber meets the road&quot; moment is because I currently have no 
mechanism for identifying and relating together two entities, such as a task and 
a note.&nbsp; It'll also mean dealing with some hardcoded tags, like here:</p>
<pre>if (insert) {
  jQuery(&quot;#template&quot;).prepend(template);
} else {
  jQuery(&quot;#template&quot;).append(template);
}</pre>
<p>The function needs to be general purpose and therefore the div associated 
with the entity has to be figured out, not hard-coded.&nbsp; So this makes more 
sense:</p>
<pre>if (insert) {
  jQuery(builder.templateContainerID).prepend(template);
} else {
  jQuery(builder.templateContainerID).append(template);
}</pre>
<p>Also, the store event callbacks are general purpose, so we can do this:</p>
<pre>this.AssignStoreCallbacks(taskStore, taskBuilder);
this.AssignStoreCallbacks(noteStore, noteBuilder);
...
private AssignStoreCallbacks(store: Store, builder: TemplateBuilder): void {
  store.recordCreatedCallback = (idx, record, insert, store) =&gt; this.CreateRecordView(builder, store, idx, record, insert);
  store.propertyChangedCallback = (idx, field, value, store) =&gt; this.UpdatePropertyView(builder, store, idx, field, value);
  store.recordDeletedCallback = (idx, store) =&gt; {
    this.DeleteRecordView(builder, store, idx);
    store.Save();
  }
}</pre>
<p>This also needs to be fixed:</p>
<pre>private DeleteRecordView(builder: TemplateBuilder, store: Store, idx: number): void {
  jQuery(`[templateIdx = '${idx}']`).remove();
}</pre>
<p>because the index number is not sufficient to determine the associated entity 
unless it's also qualified by the container name:</p>
<pre>private DeleteRecordView(builder: TemplateBuilder, store: Store, idx: number): void {
  let path = `${builder.templateContainerID} &gt; [templateIdx='${idx}']`;
  jQuery(path).remove();
}</pre>
<p>But of course this assumes that the UI will have unique container names.&nbsp; 
This leads us to the HTML that defines the layout -- templates must be in 
containers:</p>
<pre>&lt;div class=&quot;entitySeparator&quot;&gt;
  &lt;button type=&quot;button&quot; id=&quot;createTask&quot; class=&quot;createButton&quot;&gt;Create Task&lt;/button&gt;
  &lt;div id=&quot;taskTemplateContainer&quot; class=&quot;templateContainer&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;entitySeparator&quot;&gt;
  &lt;button type=&quot;button&quot; id=&quot;createNote&quot; class=&quot;createButton&quot;&gt;Create Note&lt;/button&gt;
  &lt;div id=&quot;noteTemplateContainer&quot; class=&quot;templateContainer&quot;&gt;&lt;/div&gt;
&lt;/div&gt;</pre>
<p>At this point, I can create tasks and notes:</p>
<p><img border="0" src="rel1.png" width="777" height="183"></p>
<p>and they persist quite nicely in the local storage as well:</p>
<p><img border="0" src="rel2.png" width="894" height="160"></p>
<p>To figure out next:</p>
<ol>
	<li>Some unique ID field in the record that is persisted.&nbsp; Normally 
	this would be the primary key, but we're not saving the data to a database 
	and I'd like the unique ID to be decoupled from the database's PK, 
	particularly if the user is working disconnected from the Internet, which we 
	should be able to fairly easily support.</li>
	<li>Clicking on the parent (the task in our case) should bring up the 
	specific child records.</li>
	<li>Do we have separate stores (like &quot;Task-Note&quot; and &quot;Task-Contact&quot;) for 
	each parent-child relationship or do we create a &quot;metastore&quot; with 
	parent-child entity names and this unique ID?&nbsp; Or do we create a 
	hierarchical structure where, say, a task has child elements such as notes?</li>
	<li>How do we indicate to the user the selected parent that will be 
	associated with the child entities?</li>
</ol>
<p>Regard #4, I like an unobtrusive approach like this, where the green left 
border indicates the record that's been selected.</p>
<p><img border="0" src="select1.png" width="209" height="93"></p>
<p>The trick here is that we want to remove the selection only for the entity 
records associated with the selection:</p>
<pre>private RecordSelected(builder: TemplateBuilder, recIdx: number): void {
  jQuery(builder.templateContainerID).children().removeClass(&quot;recordSelected&quot;);
  let path = `${builder.templateContainerID} &gt; [templateIdx='${recIdx}']`;
  jQuery(path).addClass(&quot;recordSelected&quot;);
}</pre>
<p>This way we can select a record for each entity type:</p>
<p><img border="0" src="select2.png" width="379" height="361"></p>
<p>Regarding #3, a hierarchical structure is out of the question, as it 
potentially creates a highly denormalized dataset.&nbsp; Consider that a task 
(or if I want to add projects at some point, a project) may have the same 
contact information.&nbsp; If I update the contact, do I want find all the 
occurrences in an arbitrary hierarchy where that contact exists and update each 
and every one of them?&nbsp; What if I delete a contact because that person no 
longer works at that company?&nbsp; Heck no.&nbsp; And separate parent-child 
stores is rejected because of the number of local storage items (or database 
tables) that it requires.&nbsp; Particularly when it comes to database tables, 
the last thing I want to do is create parent-child tables on the fly.&nbsp; So a 
single meta-store that manages the mappings of all parent-child relationships 
seems most reasonable at the moment, the major consideration is the performance 
when the &quot;table&quot; contains potentially thousands (or magnitudes more) of 
relationships.&nbsp; At this point, such a scenario doesn't need to be 
considered.</p>
<p>Here we have our first concrete model:</p>
<pre>export class ParentChildRelationshipModel {
  parent: string;
  child: string;
  parentId: number;
  childId: number;
}</pre>
<p>Notice that the parent and child ID's are numbers.&nbsp; The maximum number 
is 2<sup>1024</sup>, the problem though is that the <code>Number</code> type is a 64-bit 
floating point value, so it's not the range but the precision that is of 
concern.&nbsp; I'm guessing that finding parent-child relationships by a number 
ID rather than, say, a GUID ID, will be faster and that I don't have to worry 
about precision too much at this point.</p>
<p>And (horrors), similar to ExtJS, we actually have a concrete <code>ParentChildStore</code> 
which will have a function for acquiring a unique number ID:</p>
<pre>import { Store } from &quot;../classes/Store&quot;

export class ParentChildStore extends Store {
}</pre>
<p>The parent-child store is created a little bit differently:</p>
<pre>let parentChildRelationshipStore = new ParentChildStore(storeManager, StoreType.LocalStorage, &quot;ParentChildRelationships&quot;);
storeManager.RegisterStore(parentChildRelationshipStore);</pre>
<p>And we can access a concrete store type using this function, note the 
comments:</p>
<pre>public GetTypedStore&lt;T&gt;(storeName: string): T {
  // Compiler says: Conversion of type 'Store' to type 'T' may be a mistake because 
  // neither type sufficiently overlaps with the other. If this was intentional, 
  // convert the expression to 'unknown' first.
  // So how do I tell it that T must extended from Store?
  return (&lt;unknown&gt;this.stores[storeName]) as T;
}</pre>
<p>In C#, I would write something like <code>GetStore&lt;T&gt;(string storeName) where T : 
Store</code> and the downcast to <code>T</code> would work fine, but I have no idea how to do this in 
TypeScript.<br>
<br>
While I need a persistable counter, like a sequence, to get the next ID, let's 
look at the CreateRecord function first:</p>
<pre>public CreateRecord(insert = false): number {
  let nextIdx = 0;

  if (this.Records() &gt; 0) {
    nextIdx = Math.max.apply(Math, Object.keys(this.data)) + 1;
  }

  this.data[nextIdx] = {};        &lt;== THIS LINE IN PARTICULAR
  this.recordCreatedCallback(nextIdx, {}, insert, this);

  return nextIdx;
}</pre>
<p>
It's the assignment of the empty object that needs to set an ID, but I don't 
want to code that in the store -- I prefer to have that decoupled, so I'll 
implement it as a call to the StoreManager which will then invoke a callback to 
the application, so the unique record identifier can be something that the 
application manages.&nbsp; We could even do a &quot;per store&quot; callback, but that's 
unnecessary at this point.&nbsp; So now the store calls:</p>
<pre>this.data[nextIdx] = this.storeManager.GetPrimaryKey();</pre>
<p>
The definition for the callback is crazy 
looking, in that it defaults to returning {}:</p>
<pre>
getPrimaryKeyCallback: () =&gt; any = () =&gt; {};</pre>
<p>
and for testing, let's just implement a basic counter:</p>
<pre>
storeManager = new StoreManager();

// For testing:
let n = 0;
storeManager.getPrimaryKeyCallback = () =&gt; {
  return { __ID: ++n };
}</pre>
<p>
and we can see that this creates the primary key key-value pair when I create a 
task!</p>
<p>
<img border="0" src="pk1.png" width="225" height="47"></p>
<p>
So this is the end of Day 6.&nbsp; I still need to persist the sequence, 
probably a &quot;Sequence&quot; store that allows me to define different sequences, and of 
course create the parent-child records and the UI behavior.&nbsp; Getting there!</p>
<h2>
Day 7</h2>
<p>
So a sequence store seems like a good idea.&nbsp; Again, this can be a concrete 
model and store.&nbsp; The model:</p>
<pre>export class SequenceModel {
  key: string;
  n: number;

  constructor(key: string) {
    this.key = key;
    this.n = 0;
  }
}</pre>
<p>The <code>Sequence</code> store:</p>
<pre>import { Store } from &quot;../classes/Store&quot;
import { SequenceModel } from &quot;../models/SequenceModel&quot;

export class SequenceStore extends Store {
  GetNext(skey: string): number {
    let n = 0;
    let recIdx = this.FindRecordOfType&lt;SequenceModel&gt;(r =&gt; r.key == skey);
    
    if (recIdx == -1) {
      recIdx = this.CreateRecord();
      this.SetProperty(recIdx, &quot;key&quot;, skey);
      this.SetProperty(recIdx, &quot;count&quot;, 0);
    }

    n = this.GetProperty(recIdx, &quot;count&quot;) + 1;
    this.SetProperty(recIdx, &quot;count&quot;, n);
    this.Save();

    return n;
  }
}</pre>
<p>and the <code>FindRecordOfType</code> function:</p>
<pre>public FindRecordOfType&lt;T&gt;(where: (T) =&gt; boolean): number {
  let idx = -1;

  for (let k of Object.keys(this.data)) {
    if (where(&lt;T&gt;this.data[k])) {
      idx = parseInt(k);
      break;
    }
  }

  return idx;
}</pre>
<p>We can write a simple test:</p>
<pre>let seqStore = new SequenceStore(storeManager, StoreType.LocalStorage, &quot;Sequences&quot;);
storeManager.RegisterStore(seqStore);
seqStore.Load();
let n1 = seqStore.GetNext(&quot;c1&quot;);
let n2 = seqStore.GetNext(&quot;c2&quot;);
let n3 = seqStore.GetNext(&quot;c2&quot;);</pre>
<p>and in the local storage, we see:</p>
<p><img border="0" src="seq1.png" width="330" height="62"></p>
<p>so we can now assign sequences to each of the stores:</p>
<pre>storeManager.getPrimaryKeyCallback = (storeName: string) =&gt; {
  return { __ID: seqStore.GetNext(storeName) };</pre>
<p>Except that creating the sequence results in infinite recursion, because the 
sequence record is trying to get it's own primary key!!!</p>
<p><img border="0" src="seq2.png" width="620" height="202"></p>
<p>Oops.</p>
<p>The simplest way to deal with this is make the method overridable in the base 
class, first by refactoring the <code>CreateRecord</code> function:</p>
<pre>public CreateRecord(insert = false): number {
  let nextIdx = 0;

  if (this.Records() &gt; 0) {
    nextIdx = Math.max.apply(Math, Object.keys(this.data)) + 1;
  }

  this.data[nextIdx] = this.GetPrimaryKey();
  this.recordCreatedCallback(nextIdx, {}, insert, this);

  return nextIdx;
}</pre>
<p>Defining the default behavior:</p>
<pre>protected GetPrimaryKey(): {} {
  return this.storeManager.GetPrimaryKey(this.storeName);
}</pre>
<p>and overriding it in the SequenceStore:</p>
<pre>protected GetPrimaryKey(): {} {
  return {};
}</pre>
<p>Problem solved!</p>
<h3>Making the Association</h3>
<p>To make the association between parent and child record, we'll add a field to 
hold the selected record index in the store:</p>
<pre>selectedRecordIndex: number = undefined; // multiple selection not allowed.</pre>
<p>And in the <code>BindElementEvents</code> function, where we call <code>RecordSelected</code>, we'll 
add setting this field in the store:</p>
<pre>jel.on('focus', () =&gt; {
  this.RecordSelected(builder, recIdx));
  store.selectedRecordIndex = recIdx;
}</pre>
<p>In the event handler for the button responsible for create a task note:</p>
<pre>jQuery(&quot;#createTaskNote&quot;).on('click', () =&gt; {
  let idx = eventRouter.Route(&quot;CreateRecord&quot;, noteStore, 0); // insert at position 0
  noteStore.Save();
});</pre>
<p>We'll add a call to add the parent-child record:</p>
<pre>jQuery(&quot;#createTaskNote&quot;).on('click', () =&gt; {
  let idx = eventRouter.Route(&quot;CreateRecord&quot;, noteStore, 0); // insert at position 0
  parentChildRelationshipStore.AddRelationship(taskStore, noteStore, idx); // &lt;=== Added this
  noteStore.Save();
});</pre>
<p>With the implementation:</p>
<pre>AddRelationship(parentStore: Store, childStore: Store, childRecIdx: number): void {
  let parentRecIdx = parentStore.selectedRecordIndex;

  if (parentRecIdx !== undefined) {
    let recIdx = this.CreateRecord();
    let parentID = parentStore.GetProperty(parentRecIdx, &quot;__ID&quot;);
    let childID = childStore.GetProperty(childRecIdx, &quot;__ID&quot;);
    let rel = new ParentChildRelationshipModel(parentStore.storeName, childStore.storeName, parentID, childID);
    this.SetRecord(recIdx, rel);
    this.Save();
  } else {
    // callback that parent record needs to be selected?
    // or throw an exception?
  }
}</pre>
<p>And there we have it:</p>
<p><img border="0" src="rel3.png" width="454" height="170"></p>
<p>Now we just have to select the correct children for the selected parent.&nbsp; 
Having already defined a global variable (ugh) for declaring relationships:</p>
<pre>var relationships : Relationship = [
  {
    parent: &quot;Tasks&quot;,
    children: [&quot;Notes&quot;]
  }
];</pre>
<p>Where Relationship is defined as:</p>
<pre>export interface Relationship {
  parent: string;
  children: string[];
}</pre>
<p>We can now tie in to the same &quot;selected&quot; event handler to acquire the 
specific child relationships, remove any previous ones, and show just the 
specific ones for the selected record.&nbsp; We also don't want to go through 
this process every time a field in the record is selected.</p>
<pre>jel.on('focus', () =&gt; {
  if (store.selectedRecordIndex != recIdx) {
    this.RecordSelected(builder, recIdx);
    store.selectedRecordIndex = recIdx;
    this.ShowChildRecords(store, recIdx, relationships);
  }
});</pre>
<p>In the <code>ParentChildStore</code>, we can define:</p>
<pre>GetChildInfo(parent: string, parentId: number, child: string): ChildRecordInfo {
  let childRecs = this.FindRecordsOfType&lt;ParentChildRelationshipModel&gt;(rel =&gt; rel.parent == parent &amp;&amp; rel.parentId == parentId &amp;&amp; rel.child == child);
  let childRecIds = childRecs.map(r =&gt; r.childId);
  let childStore = this.storeManager.GetStore(child);

  // Annoying. VS2017 doesn't have an option for ECMAScript 7
  let recs = childStore.FindRecords(r =&gt; childRecIds.indexOf((&lt;any&gt;r).__ID) != -1);

  return { store: childStore, childrenIndices: recs };
}</pre>
<p>In the <code>Store</code> class, we implement:</p>
<pre>public FindRecords(where: ({ }) =&gt; boolean): number[] {
  let recs = [];

  for (let k of Object.keys(this.data)) {
    if (where(this.data[k])) {
      recs.push(k);
    }
  }

  return recs;
}</pre>
<p>This returns the record indices, which we need to populate the template <code>{idx}</code> 
value so we know what record is being edited.</p>
<p>This lovely function has the job of finding the children and populating the 
templates (some refactoring occurred here, for example, mapping a store to its 
builder):</p>
<pre>private ShowChildRecords(parentStore: Store, parentRecIdx: number, relationships: Relationship[]): void {
  let parentStoreName = parentStore.storeName;
  let parentId = parentStore.GetProperty(parentRecIdx, &quot;__ID&quot;);
  let relArray = relationships.filter(r =&gt; r.parent == parentStoreName);

  // Only one record for the parent type should exist.
  if (relArray.length == 1) {
    let rel = relArray[0];

    rel.children.forEach(child =&gt; {
      let builder = builders[child].builder;
      this.DeleteAllRecordsView(builder);
      let childRecs = parentChildRelationshipStore.GetChildInfo(parentStoreName, parentId, child);
      let childStore = childRecs.store;

      childRecs.childrenIndices.map(idx =&gt; Number(idx)).forEach(recIdx =&gt; {
        let rec = childStore.GetRecord(recIdx);
        this.CreateRecordView(builder, childStore, recIdx, rec, false);
      });
    });
  }
}</pre>
<p>And it works!&nbsp; Clicking on Task 1, where I created 2 notes:</p>
<p><img border="0" src="rel4.png" width="560" height="358"></p>
<p>Clicking on Task 2, where I created 1 note:</p>
<p><img border="0" src="rel5.png" width="559" height="258"></p>
<h3>Contacts</h3>
<p>Now let's have fun and create another child, Contacts.</p>
<p>Update the relationship map:</p>
<pre>var relationships : Relationship[] = [
  {
    parent: &quot;Tasks&quot;,
    children: [&quot;Contacts&quot;, &quot;Notes&quot;]
  }
];</pre>
<p>Update the HTML:</p>
<pre>&lt;div class=&quot;entitySeparator&quot;&gt;
  &lt;button type=&quot;button&quot; id=&quot;createTask&quot; class=&quot;createButton&quot;&gt;Create Task&lt;/button&gt;
  &lt;div id=&quot;taskTemplateContainer&quot; class=&quot;templateContainer&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;entitySeparator&quot;&gt;
  &lt;button type=&quot;button&quot; id=&quot;createTaskContact&quot; class=&quot;createButton&quot;&gt;Create Contact&lt;/button&gt;
  &lt;div id=&quot;contactTemplateContainer&quot; class=&quot;templateContainer&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;entitySeparator&quot;&gt;
  &lt;button type=&quot;button&quot; id=&quot;createTaskNote&quot; class=&quot;createButton&quot;&gt;Create Note&lt;/button&gt;
  &lt;div id=&quot;noteTemplateContainer&quot; class=&quot;templateContainer&quot;&gt;&lt;/div&gt;
&lt;/div&gt;</pre>
<p>Create the contact template:</p>
<pre>let contactTemplate = [
  { field: &quot;Name&quot;, line: 0, width: &quot;50%&quot;, control: &quot;textbox&quot; },
  { field: &quot;Email&quot;, line: 0, width: &quot;50%&quot;, control: &quot;textbox&quot; },
  { field: &quot;Comment&quot;, line: 1, width: &quot;100%&quot;, control: &quot;textbox&quot; },
  { text: &quot;Delete&quot;, line: 1, width: &quot;20%&quot;, control: &quot;button&quot;, route: &quot;DeleteRecord&quot; }
];</pre>
<p>Create the store:</p>
<pre>let contactStore = storeManager.CreateStore(&quot;Contacts&quot;, StoreType.LocalStorage);</pre>
<p>Create the builder:</p>
<pre>let contactBuilder = this.CreateHtmlTemplate(&quot;#contactTemplateContainer&quot;, contactTemplate, storeManager, contactStore.storeName);</pre>
<p>Assign the callbacks:</p>
<pre>this.AssignStoreCallbacks(contactStore, contactBuilder);</pre>

<p>Add the relationship:</p>
<pre>jQuery(&quot;#createTaskContact&quot;).on('click', () =&gt; {
  let idx = eventRouter.Route(&quot;CreateRecord&quot;, contactStore, 0); // insert at position 0
  parentChildRelationshipStore.AddRelationship(taskStore, contactStore, idx);
  contactStore.Save();
});</pre>
<p>Load the contacts but don't render them on the view (prevent the callback in 
other words):</p>
<pre>taskStore.Load();
noteStore.Load(false);
contactStore.Load(false);</pre>
<p>And there we are: we've just added another child entity to Tasks!</p>
<p><img border="0" src="rel6.png" width="555" height="261"></p>
<p>Now, having gone through that exercise, with the exception of the HTML to 
hold the contacts and the contact template itself, all the rest of the stuff we 
manually did can be handled with a function call, which will be Day 8.&nbsp; We 
also have to deal with deleting the relationship entry when a child is deleted, 
and deleting all the child relationships when a parent is deleted. Goodnight!</p>
<h2>Day 8</h2>
<p>First, let's create a function that takes all those discrete setup steps and 
rolls them into one call with a lot of parameters:</p>
<pre>private CreateStoreViewFromTemplate(
  storeManager: StoreManager,
  storeName: string,
  storeType: StoreType,
  containerName: string,
  template: Items,
  createButtonId: string,
  updateView: boolean = true,
  parentStore: Store = undefined,
  createCallback: (idx: number, store: Store) =&gt; void = _ =&gt; { }
): Store {
  let store = storeManager.CreateStore(storeName, storeType);
  let builder = this.CreateHtmlTemplate(containerName, template, storeManager, storeName);
  this.AssignStoreCallbacks(store, builder);

  jQuery(document).ready(() =&gt; {
    if (updateView) {
      this.BindElementEvents(builder, _ =&gt; true);
    }

    jQuery(createButtonId).on('click', () =&gt; {
      let idx = eventRouter.Route(&quot;CreateRecord&quot;, store, 0); // insert at position 0
      createCallback(idx, store);

      if (parentStore) {
        parentChildRelationshipStore.AddRelationship(parentStore, store, idx);
      }

      store.Save();
    });
  });

  store.Load(updateView);

  return store;
}</pre>
<p>This &quot;simplifies&quot; the creation process to four steps:</p>
<ol>
	<li>Define the template.</li>
<li>Define the container.</li>
<li>Update the relationship map.</li>
<li>Create the store view.</li>
</ol>
<p>Step 4 is now written as:</p>
<pre>let taskStore = this.CreateStoreViewFromTemplate(
  storeManager, 
  &quot;Tasks&quot;, 
  StoreType.LocalStorage, 
  &quot;#taskTemplateContainer&quot;, 
  taskTemplate, 
  &quot;#createTask&quot;, 
  true, 
  undefined, 
  (idx, store) =&gt; store.SetDefault(idx, &quot;Status&quot;, taskStates[0].text));

this.CreateStoreViewFromTemplate(
  storeManager, 
  &quot;Notes&quot;, 
  StoreType.LocalStorage, 
  &quot;#noteTemplateContainer&quot;, 
  noteTemplate, 
  &quot;#createTaskNote&quot;, 
  false, 
  taskStore);

this.CreateStoreViewFromTemplate(
  storeManager, 
  &quot;Contacts&quot;, 
  StoreType.LocalStorage, 
  &quot;#contactTemplateContainer&quot;, 
  contactTemplate, 
  &quot;#createTaskContact&quot;, 
  false, 
  taskStore);</pre>
<p>OK, a lot of parameters, but it's a highly repeatable pattern.</p>
<p>Next, we want to delete any relationships.&nbsp; The relationship needs to be 
deleted before the record is deleted because we need access to the <code>__ID</code> field, 
so we have to reverse the way the callback is handled in the Store to:</p>
<pre>public DeleteRecord(idx: number) : void {
  this.recordDeletedCallback(idx, this);
  delete this.data[idx];
}</pre>
<p>which will also allow for recursively deleting the entire hierarchy of an 
element when the element is deleted.</p>
<p>Then, in the callback handler:</p>
<pre>store.recordDeletedCallback = (idx, store) =&gt; {
  parentChildRelationshipStore.DeleteRelationship(store, idx);
  this.DeleteRecordView(builder, idx);
}</pre>
<p>But we also have to save the store now in the route handler because the 
callback, which was performing the save, is being called <i>before</i> the 
record is deleted:</p>
<pre>eventRouter.AddRoute(&quot;DeleteRecord&quot;, (store, idx) =&gt; {
  store.DeleteRecord(idx);
  store.Save();
});</pre>
<p>and the implementation in the <code>ParentChildStore</code>:</p>
<pre>public DeleteRelationship(store: Store, recIdx: number) {
  let storeName = store.storeName;
  let id = store.GetProperty(recIdx, &quot;__ID&quot;);
  let touchedStores : string[] = []; // So we save the store only once after this process.

  // safety check.
  if (id) {
    let parents = this.FindRecordsOfType&lt;ParentChildRelationshipModel&gt;(rel =&gt; rel.parent == storeName &amp;&amp; rel.parentId == id);
    let children = this.FindRecordsOfType&lt;ParentChildRelationshipModel&gt;(rel =&gt; rel.child == storeName &amp;&amp; rel.childId == id);

    // All children of the parent are deleted.
    parents.forEach(p =&gt; {
      this.DeleteChildrenOfParent(p, touchedStores);
    });

    // All child relationships are deleted.
    children.forEach(c =&gt; {
      let relRecIdx = this.FindRecordOfType&lt;ParentChildRelationshipModel&gt;((r: ParentChildRelationshipModel) =&gt;
      r.parent == c.parent &amp;&amp;
      r.parentId == c.parentId &amp;&amp;
      r.child == c.child &amp;&amp;
      r.childId == c.childId);
    this.DeleteRecord(relRecIdx);
    });
  } else {
    console.log(`Expected to have an __ID value in store ${storeName} record index: ${recIdx}`);
  }

  // Save all touched stores.
  touchedStores.forEach(s =&gt; this.storeManager.GetStore(s).Save());

  this.Save();
}</pre>
<p>with a helper function:</p>
<pre>private DeleteChildrenOfParent(p: ParentChildRelationshipModel, touchedStores: string[]): void {
  let childStoreName = p.child;
  let childId = p.childId;
  let childStore = this.storeManager.GetStore(childStoreName);
  let recIdx = childStore.FindRecord(r =&gt; (&lt;any&gt;r).__ID == childId);

  // safety check.
  if (recIdx != -1) {
    // Recursive deletion of child's children will occur (I think - untested!)
    childStore.DeleteRecord(recIdx);

    if (touchedStores.indexOf(childStoreName) == -1) {
      touchedStores.push(childStoreName);
    }
  } else {
    console.log(`Expected to find record in store ${childStoreName} with __ID = ${childId}`);
  }

  // Delete the parent-child relationship.
  let relRecIdx = this.FindRecordOfType&lt;ParentChildRelationshipModel&gt;((r: ParentChildRelationshipModel) =&gt;
    r.parent == p.parent &amp;&amp;
    r.parentId == p.parentId &amp;&amp;
    r.child == p.child &amp;&amp;
    r.childId == childId);

  this.DeleteRecord(relRecIdx);
}</pre>
<h2>Day 9: Bugs</h2>
<p>So in creating a more rich relationship model:</p>
<pre>var relationships : Relationship[] = [
{
  parent: &quot;Projects&quot;,
  children: [&quot;Tasks&quot;, &quot;Contacts&quot;, &quot;Notes&quot;]
},
{
  parent: &quot;Tasks&quot;,
  children: [&quot;Notes&quot;]
}
];</pre>
<p>in which Notes are children of both Projects and Tasks, a couple bugs came 
up.&nbsp; </p>
<h3>Bug: Create a Store Only Once</h3>
<p>First is the issue that I was creating the Notes store twice, which is 
fixed checking if the store exists:</p>
<pre>private CreateStoreViewFromTemplate(
...
): Store {

// ?. operator. 
// Supposedly TypeScript 3.7 has it, but I can't select that version in VS2017. VS2019?
let parentStoreName = parentStore &amp;&amp; parentStore.storeName || undefined;
let builder = this.CreateHtmlTemplate(containerName, template, storeManager, storeName, parentStoreName);
let store = undefined;

if (storeManager.HasStore(storeName)) {
  store = storeManager.GetStore(storeName);
} else {
  store = storeManager.CreateStore(storeName, storeType);
  this.AssignStoreCallbacks(store, builder);
}</pre>
<h3>Bug: Associate the Builder with the correct Parent-Child Context</h3>
<p>Second, the builder has to be parent-child aware so that &quot;Create Task Note&quot; 
uses the Task-Note builder, not the Project-Note builder.&nbsp; This was easy 
enough (though sort of kludgy) to fix:</p>
<pre>private GetBuilderName(parentStoreName: string, childStoreName: string): string {
  return (parentStoreName || &quot;&quot;) + &quot;-&quot; + childStoreName;
}</pre>
<p>And...</p>
<pre>private CreateHtmlTemplate(templateContainerID: string, template: Items, storeManager: StoreManager, storeName: string, parentStoreName: string): TemplateBuilder {
  let builder = new TemplateBuilder(templateContainerID);
  let builderName = this.GetBuilderName(parentStoreName, storeName);
  builders[builderName] = { builder, template: templateContainerID };
  ...</pre>
<h3>Bug: Associate the CRUD Operations with the Correct Builder Context</h3>
<p>The third problem is more insidious, in the call to <code>AssignStoreCallbacks</code>:</p>
<pre>private AssignStoreCallbacks(store: Store, builder: TemplateBuilder): void {
  store.recordCreatedCallback = (idx, record, insert, store) =&gt; this.CreateRecordView(builder, store, idx, insert);
  store.propertyChangedCallback = (idx, field, value, store) =&gt; this.UpdatePropertyView(builder, store, idx, field, value);
  store.recordDeletedCallback = (idx, store) =&gt; {
    parentChildRelationshipStore.DeleteRelationship(store, idx);
    this.DeleteRecordView(builder, idx);
  }
}</pre>
<p>The problem here is that the builder is the one associated with the store 
when the store is first created.&nbsp; The bug is that because this is the Notes 
store for the Project-Notes builder, adding a Task-Note adds the note to the 
Project-Notes instead!&nbsp; Two things need to happen:</p>
<ol>
	<li>There should only be one callback for the store.</li>
	<li>But the builder must be specific to the &quot;context&quot; of the CRUD operation.</li>
</ol>
<p>The fix for this is to pass into the store the &quot;context&quot; for the CRUD 
operations.&nbsp; At the moment I'm just passing in the <code>TemplateBuilder</code> instance 
because I'm too lazy to create a <code>Context</code> class and I'm not sure it's needed:</p>
<p>The upshot of it is that the CRUD callbacks now get the builder context which 
they pass along to the handler:</p>
<pre>private AssignStoreCallbacks(store: Store): void {
  store.recordCreatedCallback = (idx, record, insert, store, builder) =&gt; this.CreateRecordView(builder, store, idx, insert);
  store.propertyChangedCallback = (idx, field, value, store, builder) =&gt; this.UpdatePropertyView(builder, store, idx, field, value);
  store.recordDeletedCallback = (idx, store, builder) =&gt; {
    parentChildRelationshipStore.DeleteRelationship(store, idx);
    this.DeleteRecordView(builder, idx);
  }
}</pre>
<h3>Two Bugs, Same Solution</h3>
<ul>
	<li>Grandchild Views Need to be Removed When Child List Changes</li>
<li>Deleting a Parent Should Remove Child Template Views</li>
</ul>
<p>If I create a two projects with different tasks and task notes, where the 
task note is the grandchild, when I select a different project, the project 
children update (the project tasks) but the task notes remain on-screen, which 
leads to a lot of confusion.&nbsp; The function ShowChildRecords is great, but 
we need to remove grandchild records as the child context has changed.&nbsp; So 
this piece of code:</p>
<pre>jel.on('focus', () =&gt; {
  if (store.selectedRecordIndex != recIdx) {
    this.RecordSelected(builder, recIdx);
    store.selectedRecordIndex = recIdx;
    this.ShowChildRecords(store, recIdx, relationships);
  }
});</pre>
<p>Gets an additional function call:</p>
<pre>jel.on('focus', () =&gt; {
  if (store.selectedRecordIndex != recIdx) {
    this.RemoveChildRecordsView(store, store.selectedRecordIndex);
    this.RecordSelected(builder, recIdx);
    store.selectedRecordIndex = recIdx;
    this.ShowChildRecords(store, recIdx, relationships);
  }
});</pre>
<p>which is implemented as:</p>
<pre>// Recursively remove all child view records.
private RemoveChildRecordsView(store: Store, recIdx: number): void {
  let storeName = store.storeName;
  let id = store.GetProperty(recIdx, &quot;__ID&quot;);
  let rels = relationships.filter(r =&gt; r.parent == storeName);

  if (rels.length == 1) {
    let childEntities = rels[0].children;

    childEntities.forEach(childEntity =&gt; {
      if (storeManager.HasStore(childEntity)) {
        var info = parentChildRelationshipStore.GetChildInfo(storeName, id, childEntity);
        info.childrenIndices.forEach(childRecIdx =&gt; {
          let builderName = this.GetBuilderName(storeName, childEntity);
          let builder = builders[builderName].builder;
          this.DeleteRecordView(builder, childRecIdx);
          this.RemoveChildRecordsView(storeManager.GetStore(childEntity), childRecIdx);
        });
      }
    });
  }
}</pre>
<h3>Bug: The Selected Record is Parent-Child Dependent</h3>
<p><b>Note: the following thought process is WRONG!</b>&nbsp; I'm keeping this 
in here because it was something I thought was wrong and only on further 
reflection did I realize it was not wrong.&nbsp; Unit tests would validate my 
belief that the writeup here is incorrect!</p>
<p>So here goes in the wrong thinking:</p>
<p>When a store is shared between two different parents, the selected record is 
specific to the parent-child relationship, not the store!&nbsp; </p>
<h4>Question: Is Parent-Child Sufficient to Describe the Uniqueness and Entity?</h4>
<p>No.&nbsp; For example, if I have a parent-child relationship B-C, and a 
hierarchy of A-B-C and D-B-C, the specific context of the records in C is 
associated with its relationship to B's records.&nbsp; And while B's context is 
in relationship to A's records, the selected record for the store depends on 
whether the entity path is A-B-C or D-B-C.&nbsp; Please realize that &quot;A&quot; and &quot;D&quot; 
different <i>entity types</i>, not different records of the same entity.</p>
<p>Even the template builder name is not a 2-level parent-child relationship.&nbsp; 
This works so far because the relationships are all uniquely defined with two 
levels of hierarchy.&nbsp; But insert another top level to the hierarchy and the 
template builder name's relationship to the builder (and the specific <code>templateContainerID</code> 
with which the builder is associated) fails.</p>
<h4>Solution</h4>
<p>This means that if we don't want to keep fixing up the code, we have to have 
a general purpose solution to the issue of identifying:</p>
<ol>
	<li>The correct builder;</li>
	<li>The selected record;</li>
</ol>
<p>as they are associated with the <i>entity type</i> hierarchy, no matter how 
deep.&nbsp; Keep in mind that the parent-child relationship model is still valid 
because it is associating relationships between parent and child entity <i>
instances</i> whereas the builder and UI management is working often with the <i>
entity type</i> hierarchy.</p>
<h4>Why This is Not a Bug</h4>
<p>First, when we load the records of parent-child relationship, it is qualified 
by the parent ID, which is unique:</p>
<pre>let childRecs = parentChildRelationshipStore.GetChildInfo(parentStoreName, parentId, child);</pre>
<p>and in the <code>GetChildInfo</code> function:</p>
<pre>let childRecs = this.FindRecordsOfType&lt;ParentChildRelationshipModel&gt;(rel =&gt; rel.parent == parent &amp;&amp; rel.parentId == parentId &amp;&amp; rel.child == child);</pre>
<h4>But What is a Bug is This</h4>
<p>In the above two items, &quot;the correct builder&quot; and &quot;the selected record&quot;, the 
correct builder must be determined by the <i>entity type</i> hierarchy which 
needs the full path to determine the template container, but the selected record 
is associated with the <i>instance</i> and so is not actually the issue.</p>
<p>The code identifies the appropriate builder, which includes the HTML 
container template name, using:</p>
<pre>let builderName = this.GetBuilderName(parentStoreName, child);</pre>
<p>which is determined by:</p>
<pre>private GetBuilderName(parentStoreName: string, childStoreName: string): string {
  return (parentStoreName || &quot;&quot;) + &quot;-&quot; + childStoreName;
}</pre>
<p>So here we see that the builder associated with B-C does not have enough 
information to determine the template container for A-B-C vs. D-B-C.&nbsp; And 
that's where the real bug is.&nbsp; The upshot of this is that it's very 
important to distinguish between <i>type</i> and <i>instance</i>.</p>
<p>This will be addressed in Day 12, The Parent-Child Template Problem.</p>
<h3>Nicety: Focus on First Field when Adding a Record</h3>
<p>Trying to avoid unnecessary clicks, this:</p>
<pre>private FocusOnFirstField(builder: TemplateBuilder, idx: number) {
  let tel = builder.elements[0];
  let guid = tel.guid.ToString();
  jQuery(`[bindGuid = '${guid}'][storeIdx = '${idx}']`).focus();
}</pre>
<p>when called here:</p>
<pre>store.recordCreatedCallback = (idx, record, insert, store, builder) =&gt; {
  this.CreateRecordView(builder, store, idx, insert);
  this.FocusOnFirstField(builder, idx);
};</pre>
<p>Makes life a lot nicer.</p>
<h2>Day 10: A Few More Niceties</h2>
<p>So I've also added links at the project and task level so I can reference internal and 
online links that are related to the project:</p>
<pre>var relationships : Relationship[] = [
  {
    parent: &quot;Projects&quot;,
    children: [&quot;Tasks&quot;, &quot;Contacts&quot;, &quot;Links&quot;, &quot;Notes&quot;]
  },
  {
    parent: &quot;Tasks&quot;,
    children: [&quot;Links&quot;, &quot;Notes&quot;]
  }
];</pre>
<p>And the related HTML and template were created as well.</p>
<h3>This is How Life Should Work</h3>
<p>Just now I also decided I wanted to add &quot;Title&quot; to the Contact.&nbsp; So all 
I did was add this line to the <code>contactTemplate</code>:</p>
<pre>{ field: &quot;Title&quot;, line: 0, width: &quot;30%&quot;, control: &quot;textbox&quot; },</pre>
<p>Done.&nbsp; What didn't have to happen was that I didn't have to change some 
model definition of the client-side.&nbsp; And of course I didn't have to 
implement a DB-schema migration, and I didn't have change some EntityFramework 
or Linq2SQL entity model in C#.&nbsp; Frankly, when I add server-side database 
support, I still don't want to do any of that stuff!&nbsp; I should be able to 
touch one place and one place only: the template that describes what fields I 
want to see and where they are.&nbsp; Everything else should just figure out how 
to adjust.</p>
<h2>Day 11: Colorizing Status</h2>
<p>This is a bit of a hack, but I want to visually indicate the status of a 
project and task by colorizing the dropdown:</p>
<p><img border="0" src="statuscolor1.png" width="180" height="211"></p>
<p>This didn't take all day, it's just the time I had available.</p>
<p>Implemented by handling the <code>change</code>, <code>focus</code>, and <code>blur</code> events -- when the 
dropdown gets focus, it goes back to white so the entire selection list doesn't 
have the background color of the current status:</p>
<pre>case &quot;combobox&quot;:
  jel.on('change', () =&gt; {
    // TODO: Move this very custom behavior out into a view handler
    let val = this.SetPropertyValue(builder, jel, el, recIdx);
    this.SetComboboxColor(jel, val);
  });

  // I can't find an event for when the option list is actually shown, so for now 
  // we reset the background color on focus and restore it on lose focus.
  jel.on('focus', () =&gt; {
    jel.css(&quot;background-color&quot;, &quot;white&quot;);
  });

  jel.on('blur', () =&gt; {
    let val = jel.val();
    this.SetComboboxColor(jel, val);
  });
  break;</pre>
<p>and when the record view is created:</p>
<pre>private CreateRecordView(builder: TemplateBuilder, store: Store, idx: number, insert: boolean): void {
  ...
 // Hack!
  if (tel.item.control == &quot;combobox&quot;) {
    this.SetComboboxColor(jel, val);
  }
}</pre>
<h2>Day 12 - The Parent-Child Template Problem</h2>
<p>So this:</p>
<pre>private GetBuilderName(parentStoreName: string, childStoreName: string): string {
  return (parentStoreName || &quot;&quot;) + &quot;-&quot; + childStoreName;
}</pre>
<p>is a hack.&nbsp; The global variables are also a hack, as is storing the 
selected record index in the store -- it should be associated with the view 
controller <i>for that store</i>, not the store! Hacks should be revisited or not even implemented in the 
first place!&nbsp; The whole problem here is that the element events are not 
coupled with an object that retains information about the &quot;event trigger&quot;, if 
you will, and therefore determining the builder associated with the event became 
a hack.&nbsp; What's needed here is a container for the binder, template ID, 
etc., that is bound to the specific UI events for that builder - in other words, 
a view controller.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

</body>

</html>