<ul class="download">
	<li><a href="TaskTracker.zip">Download TaskTracker.zip - 355.7 KB</a></li>
</ul>

<p><img border="0" height="412" src="screenshot.png" width="823" /></p>

<p>This screenshot is only a subset of what&#39;s been implemented here.&nbsp; On the right are additional links associated with projects and tasks:</p>

<p><img border="0" height="292" src="screenshot2.png" width="611" /></p>

<h2><a name="0">Table Of Contents</a></h2>

<div id="toc">
<ul>
	<li>
	<ul>
		<li><a href="#0">Table Of Contents</a></li>
		<li><a href="#1">Introduction</a></li>
		<li><a href="#2">Day 1 - General Concepts</a></li>
		<li><a href="#3">Day 2 - Some Structure Concepts for the Metadata</a>
		<ul>
			<li><a href="#4">Status</a></li>
		</ul>
		</li>
		<li><a href="#5">Day 3 - Templates</a></li>
		<li><a href="#6">Day 4 - Late Binding</a></li>
		<li><a href="#7">Day 5 - Store Callbacks</a>
		<ul>
			<li><a href="#8">Deleting a Task</a></li>
			<li><a href="#9">Event Router</a></li>
			<li><a href="#10">Inserting Tasks</a></li>
		</ul>
		</li>
		<li><a href="#11">Day 6 - Basic Relationships</a></li>
		<li><a href="#12">Day 7 - Sequence Store and the Parent-Child Relationship Store</a>
		<ul>
			<li><a href="#13">Making the Association</a></li>
			<li><a href="#14">Contacts</a></li>
		</ul>
		</li>
		<li><a href="#15">Day 8 - Simplifying the Create View Steps</a></li>
		<li><a href="#16">Day 9: Bugs</a>
		<ul>
			<li><a href="#17">Bug: Create a Store Only Once</a></li>
			<li><a href="#18">Bug: Associate the Builder with the correct Parent-Child Context</a></li>
			<li><a href="#19">Bug: Associate the CRUD Operations with the Correct Builder Context</a></li>
			<li><a href="#20">Two Bugs, Same Solution</a></li>
			<li><a href="#21">Bug: The Selected Record is Parent-Child Dependent</a>
			<ul>
				<li><a href="#22">Question: Is Parent-Child Sufficient to Describe the Uniqueness and Entity?</a></li>
				<li><a href="#23">Solution</a></li>
				<li><a href="#24">Why This is Not a Bug</a></li>
				<li><a href="#25">But What is a Bug is This</a></li>
			</ul>
			</li>
			<li><a href="#26">Nicety: Focus on First Field when Adding a Record</a></li>
		</ul>
		</li>
		<li><a href="#27">Day 10: A Few More Niceties</a>
		<ul>
			<li><a href="#28">This is How Life Should Work</a></li>
		</ul>
		</li>
		<li><a href="#29">Day 11: Colorizing Status</a></li>
		<li><a href="#30">Day 12 - The Parent-Child Template Problem</a></li>
		<li><a href="#31">Day 13 - Audit Log</a>
		<ul>
			<li><a href="#32">Store Persistence Inversion of Control</a></li>
			<li><a href="#33">Audit Log</a></li>
		</ul>
		</li>
		<li><a href="#34">Day 14 - Server-Side Persistence</a>
		<ul>
			<li><a href="#35">Async Client-Side Calls</a></li>
			<li><a href="#36">Server-Side Handlers</a></li>
			<li><a href="#37">Model-less SQL</a></li>
		</ul>
		</li>
		<li><a href="#38">Day 15 - Creating the Schema on the Fly</a>
		<ul>
			<li><a href="#39">Send the Audit Log</a></li>
			<li><a href="#40">Save the Audit Log</a></li>
			<li><a href="#41">Load the Current Schema</a></li>
			<li><a href="#42">Create Stores (Tables) and Columns on the Fly</a></li>
			<li><a href="#43">Save the Audit Log</a></li>
			<li><a href="#44">Update the Schema on the Fly</a></li>
		</ul>
		</li>
		<li><a href="#45">Day 16 - More Bugs</a>
		<ul>
			<li><a href="#46">Bug in How Entity __ID is Working</a></li>
			<li><a href="#47">Forgot to Register the Common Fields Bug</a></li>
		</ul>
		</li>
		<li><a href="#49">Bonus Day 17 - Entity Menu Bar</a>
		<li><a href="#50">Running the Application</a>
		<li><a href="#48">Conclusion</a></li>
	</ul>
	</li>
</ul>
</div>

<h2><a name="1">Introduction</a></h2>

<p>I thought it would be fun and hopefully interested to document the creation of a client-side TypeScript application from concept to implementation.&nbsp; So I chose something that I&#39;ve been wanting to do for a while - a project-task manager that is tailored to my very specific requirements.&nbsp; But I also wanted this implementation to be highly abstract, which means metadata for the UI layout and parent-child entity relationships.&nbsp; In other words, at the end of the day the physical index.html page looks like this (a snippet):</p>

<pre lang="html">
&lt;div class=&quot;row col1&quot;&gt;
  &lt;div class=&quot;entitySeparator&quot;&gt;
    &lt;button type=&quot;button&quot; id=&quot;createProject&quot; class=&quot;createButton&quot;&gt;Create Project&lt;/button&gt;
    &lt;div id=&quot;projectTemplateContainer&quot; class=&quot;templateContainer&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;row col2&quot;&gt;
  &lt;div class=&quot;entitySeparator&quot;&gt;
    &lt;button type=&quot;button&quot; id=&quot;createProjectContact&quot; class=&quot;createButton&quot;&gt;Create Contact&lt;/button&gt;
    &lt;div id=&quot;projectContactTemplateContainer&quot; class=&quot;templateContainer&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
    &lt;div class=&quot;entitySeparator&quot;&gt;
    &lt;button type=&quot;button&quot; id=&quot;createProjectNote&quot; class=&quot;createButton&quot;&gt;Create Project Note&lt;/button&gt;
    &lt;div id=&quot;projectNoteTemplateContainer&quot; class=&quot;templateContainer&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
    &lt;div class=&quot;entitySeparator&quot;&gt;
    &lt;button type=&quot;button&quot; id=&quot;createProjectLink&quot; class=&quot;createButton&quot;&gt;Create Link&lt;/button&gt;
    &lt;div id=&quot;projectLinkTemplateContainer&quot; class=&quot;templateContainer&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre>

<p>Where the real work is done client-side in creating the container content.&nbsp; So what this article covers is one way to go about creating such an implementation as a general purpose parent-child entity editor but in the context of a specific project-task manager, and you get to see the evolution from concept to working application that took place over 15 &quot;days.&quot;</p>

<p>And as you&#39;ve probably come to expect, I explore a couple new concepts as well:</p>

<ol>
	<li>Except for concrete models, there entire &quot;model&quot; concept is thrown out the window.&nbsp; The view defines the model!</li>
	<li>Table and column generation as needed on the fly.&nbsp; Yup.</li>
</ol>

<p>By the way, days are not contiguous -- while each day documents the work I did, it does not mean that I worked on this each and every day.&nbsp; Particularly Day 12 encompasses a physical timespan of 3 days (and no, not 8 hours days!)&nbsp; Also you should realize that each day includes updating the article itself!</p>

<p>Also, yes, this could be implemented with grids but the default HTML grid functionality is atrocious and I didn&#39;t want to bring in other third party libraries for these articles.&nbsp; My favorite is jqWidgets, pretty much none other will do (even though it&#39;s large) so maybe at some point I&#39;ll demonstrate how to tie all this stuff in to their library.</p>

<h2><a name="2">Day 1 - General Concepts</a></h2>

<p>Some rough sketches:</p>

<p><img border="0" height="411" src="sketch1.png" width="617" /></p>

<p><img border="0" height="141" src="sketch2.png" width="633" /></p>

<ul>
	<li>It becomes clear looking at the layout that it is really more of a template for my own requirements and that the actual &quot;task item bar&quot; on the left as well as the specific fields for each task item should be completely user definable in terms of label, content, and control.&nbsp;</li>
	<li>This pretty much means that we&#39;re looking at a NoSQL database structure with loose linkages between tasks and task items.&nbsp; The &quot;root&quot; of everything still remains the task, but the task items and their fields is really quite arbitrary.</li>
	<li>So we need to be able to define the structure and its field content as one &quot;database&quot; of how the user wants to organize the information.</li>
	<li>Certain fields end up being arrays (like URL links) that are represented discretely, while other fields (like notes) may be shows discretely as a scrollable collection of distinct textarea entries or more as a &quot;document&quot; where the user simply scrolls through a single textarea.</li>
	<li>Searching - the user should be able to search on any field or a specific area, such as &quot;notes.&quot;&nbsp;</li>
	<li>Any field can be either a singleton (like a date/time on a communication) or a collection, like a list of contacts for that communication.</li>
	<li>So what we end up doing first is defining an arbitrary schema with enough metadata to describe the layout and controls of the fields in the schema as well as actions on schema elements, for example the task item bar can be represented as schema elements but they are buttons, not user input controls.</li>
	<li>We don&#39;t want to go overboard with this!&nbsp; The complexity with this approach is that the page is not static -- the entire layout has to be generated from the metadata, so the question is, server-side generation or client-side?</li>
	<li>Personally I prefer client-side.&nbsp; The server should be minimally involved with layout -- the server should serve content, as in data, not layout.&nbsp; This approach also facilitates development of the UI without needing a server and keeps all the UI code on the client rather than spreading it across both JavaScript and C# on the back-end.&nbsp; And no, I&#39;m not interested in using node.js on the back-end.</li>
</ul>

<h2><a name="3">Day 2 - Some Structure Concepts for the Metadata</a></h2>

<p>We should be able to have a fairly simple structures.&nbsp; Let&#39;s define a few, all of which are of course customizable but we&#39;ll define some useful defaults.</p>

<h3><a name="4">Status</a></h3>

<p>I like to have a fairly specific status and get frustrated when I can&#39;t put that information in a simple dropdown that lets me see at a glance what&#39;s going on with the task.&nbsp; So, I like things like:</p>

<ul>
	<li>Todo</li>
	<li>Working on</li>
	<li>Testing</li>
	<li>QA</li>
	<li>Production (Completed)</li>
	<li>Waiting for 3rd Party</li>
	<li>Waiting for Coworker</li>
	<li>Waiting on Management</li>
	<li>Stuck</li>
</ul>

<p>Notice that I don&#39;t have a priority next to the task.&nbsp; I really don&#39;t give a sh*t about priorities -- there&#39;s usually a lot of things going on and I work on what I&#39;m in the mood for and what I can work on.&nbsp; Of course, if you like priorities, you can add them to the UI.</p>

<p>Notice that I also don&#39;t categorize tasks into, for example, sprints, platforms, customers, etc.&nbsp; Again, if you want those things, you can add them.</p>

<p>What I do want is:</p>

<ol>
	<li>What is the task?</li>
	<li>What is its state?</li>
	<li>One line description of why it&#39;s in that state.</li>
</ol>

<p>So this is what I want to see (of course, what you want to see is going to be different):</p>

<p><img border="0" height="62" src="atask.png" width="442" /></p>

<p>How would we define this layout in JSON so that you can create whatever needs your needs?&nbsp; Pretty much this means figuring out how to meet my needs first!</p>

<p>This might be the definition of the high level task list:</p>

<pre lang="jscript">
[
  {
    Item:
    {
      Field: &quot;Task&quot;,
      Line: 0,
      Width: &quot;80%&quot;
    }
  },
  {
    Item:
    {
      Field: &quot;Status&quot;,
      SelectFrom: &quot;StatusList&quot;,
      OrderBy: &quot;StatusOrder&quot;,
      Line: 0,
      Width: &quot;20%&quot;
    }
  },
  {
    Item:
    {
      Field: &quot;Why&quot;,
      Line: 1,
      Width: &quot;100%&quot;
    }
  }
]</pre>

<p>These fields are all inline editable but we also want to support drilling into a field to view it&#39;s sub-records.&nbsp; Not all fields have sub-records (like Status), but this is determined by the metadata structure, so Status could have sub-records.&nbsp; Any time the user focuses on a control with sub-structures, the button bar will update and the &quot;show on select&quot; sub-structures will display the sub-records.</p>

<p>So we can define sub-structures, or allowable child records, like this using the Task entity as an example:</p>

<pre lang="jscript">
[
  {Entity:&quot;Contact&quot;, Label:&quot;Contacts&quot;},
  {Entity:&quot;Link&quot;, Label:&quot;Links&quot;, &quot;ShowOnParentSelect&quot;: true},
  {Entity:&quot;KeyPoint&quot;, Label: &quot;Key Points&quot;},
  {Entity:&quot;Note&quot; Label: &quot;Notes&quot;, &quot;ShowOnParentSelect&quot;: true},
  {Entity:&quot;Communication&quot;, Label: &quot;Communications&quot;}
]</pre>

<p>Note that all sub-structures are defined in their singular form and we have complete flexibility as to the label used to represent the link.&nbsp; These &quot;show on parent select&quot; will always be visible unless the user collapses that section, and they are rendered in the order they appear in the list above.&nbsp; Where they render is determined by other layout information.</p>

<p>Other things to think about:</p>

<ul>
	<li>Sub-tasks (easy to do)</li>
	<li>Task dependencies</li>
</ul>

<h2><a name="5">Day 3 - Templates</a></h2>

<p>So, the more I think about this, the more I realize that this is really a very generalized entity creator/editor with not quite dynamic relationships, much as I&#39;ve written about in my <a href="https://www.codeproject.com/Articles/298818/Relationship-Oriented-Programming"> Relationship Oriented Programming</a> articles.&nbsp; So it seems natural that allowable relationships should be definable as well.&nbsp; But what I&#39;d prefer to do at this point is some prototyping to get a sense of how some of these ideas can come to fruition.&nbsp; So let&#39;s start with the JSON above and write a function that turns it into an HTML template that can then be repeatedly applied as necessary.&nbsp; And at the same time, I&#39;ll be learning the nuances of TypeScript!</p>

<p>With some coding, I get this:</p>

<p><img border="0" height="58" src="prototype1.png" width="306" /></p>

<p>Defined by the template array:</p>

<pre lang="jscript">
let template = [ // Task Template
  {
    field: &quot;Task&quot;,
    line: 0,
    width: &quot;80%&quot;,
    control: &quot;textbox&quot;,
  },
  { 
    field: &quot;Status&quot;,
    selectFrom: &quot;StatusList&quot;,
    orderBy: &quot;StatusOrder&quot;,
    line: 0,
    width: &quot;20%&quot;,
    control: &quot;combobox&quot;,
  },
  {
    field: &quot;Why&quot;,
    line: 1,
    width: &quot;100%&quot;,
    control: &quot;textbox&quot;,
  }
];</pre>

<p>and the support of interfaces to define the template object model and a Builder class to put together the HTML:</p>

<pre lang="jscript">
interface Item {
  field: string;
  line: number;
  width: string;
  control: string;
  selectedFrom?: string;
  orderBy?: string;
}

interface Items extends Array&lt;Item&gt; { }

class Builder {
  html: string;

  constructor() {
    this.html = &quot;&quot;;
  }

  public DivBegin(item: Item): Builder {
    this.html += &quot;&lt;div style=&#39;float:left; width:&quot; + item.width + &quot;&#39;&gt;&quot;;

    return this;
  }

  public DivEnd(): Builder {
    this.html += &quot;&lt;/div&gt;&quot;;

    return this;
  }

  public DivClear(): Builder {
    this.html += &quot;&lt;div style=&#39;clear:both&#39;&gt;&lt;/div&gt;&quot;;

    return this;
  }

  public TextInput(item: Item): Builder {
    let placeholder = item.field;
    this.html += &quot;&lt;input type=&#39;text&#39; placeholder=&#39;&quot; + placeholder + &quot;&#39; style=&#39;width:100%&#39;&gt;&quot;;

    return this;
  }

  public Combobox(item: Item): Builder {
    this.SelectBegin().Option(&quot;A&quot;).Option(&quot;B&quot;).Option(&quot;C&quot;).SelectEnd();

    return this;
  }

  public SelectBegin(): Builder {
    this.html += &quot;&lt;select style=&#39;width:100%; height:21px&#39;&gt;&quot;;

    return this;
  }

  public SelectEnd(): Builder {
    this.html += &quot;&lt;/select&gt;&quot;;

    return this;
  }

  public Option(text: string, value?: string): Builder {
    this.html += &quot;&lt;option value=&#39;&quot; + value + &quot;&#39;&gt;&quot; + text + &quot;&lt;/option&gt;&quot;;

    return this;
  }
}</pre>

<p>This leaves only the logic for constructing the template:</p>

<pre lang="jscript">
private CreateHtmlTemplate(template: Items) : string {
  let builder = new Builder();
  let line = -1;
  let firstLine = true;

  template.forEach(item =&gt; {
    if (item.line != line) {
      line = item.line;

      if (!firstLine) {
        builder.DivClear();
      }

      firstLine = false;
    }

    builder.DivBegin(item);

    switch (item.control) {
      case &quot;textbox&quot;:
        builder.TextInput(item);
        break;

      case &quot;combobox&quot;:
        builder.Combobox(item);
        break;
      }

    builder.DivEnd();
  });

  builder.DivClear();

  return builder.html;
}</pre>

<p>So the top-level code just does this:</p>

<pre lang="jscript">
let html = this.CreateHtmlTemplate(template);
jQuery(&quot;#template&quot;).html(html);</pre>

<p>If I chain the template:</p>

<pre lang="jscript">
jQuery(&quot;#template&quot;).html(html + html + html);</pre>

<p>I get:</p>

<p><img border="0" height="141" src="prototype2.png" width="307" /></p>

<p>Cool.&nbsp; May not be the prettiest thing, but the basics are what I&#39;m looking for.</p>

<p>Now personally what bugs me to no end is that the template object reminds me of ExtJs: basically a collection of arbitrary keys to define the layout of the UI.&nbsp; Maybe it&#39;s unavoidable, and I certainly am not going down the route that ExtJs uses which is to create custom ID&#39;s that change every time the page is refreshed.&nbsp; Talk about killing the ability to do test automation at the UI level.&nbsp; It is ironic though, in writing something like this, I begin to actually have a better understanding of the design decisions that ExtJs made.</p>

<p>Which brings us to how the comboboxes are actually populated.&nbsp; So yeah, there&#39;s a concept of a &quot;store&quot; in ExtJs, and manipulating the store automatically (or that&#39;s the theory) updates the UI.&nbsp; That&#39;s too much for me right now, but I do want the ability to use an existing object or fetch (and potentially cache) the object from a REST call.&nbsp; So let&#39;s put something simple together.&nbsp; Here&#39;s my states:</p>

<pre lang="jscript">
let taskStates = [
  { text: &#39;TODO&#39;},
  { text: &#39;Working On&#39; },
  { text: &#39;Testing&#39; },
  { text: &#39;QA&#39; },
  { text: &#39;Done&#39; },
  { text: &#39;On Production&#39; },
  { text: &#39;Waiting on 3rd Party&#39; },
  { text: &#39;Waiting on Coworker&#39; },
  { text: &#39;Waiting on Management&#39; },
  { text: &#39;Stuck&#39; },
];</pre>

<p>With a little refactoring:</p>

<pre lang="jscript">
export interface Item {
  field: string;
  line: number;
  width: string;
  control: string;
  storeName?: string;  // &lt;== this got changed to &quot;storeName&quot;
  orderBy?: string;
}</pre>

<p>and the prototype concept of a store:</p>

<pre lang="jscript">
interface KeyStoreMap {
  [key: string] : any;  // Eventually &quot;any&quot; will be replaced with a more formal structure.
}

export class Store {
  stores: KeyStoreMap = {};

  public AddLocalStore(key: string, store: any) {
  this.stores[key] = store;
  }

  // Eventually will support local stores, REST calls, caching, computational stores, and using other 
  // existing objects as stores.
  public GetStore(key: string) {
    return this.stores[key];
  }
}</pre>

<p>I now do this:</p>

<pre lang="jscript">
let store = new Store();
store.AddLocalStore(&quot;StatusList&quot;, taskStates);
let html = this.CreateHtmlTemplate(template, store);</pre>

<p>and the template builder does this:</p>

<pre lang="jscript">
public Combobox(item: Item, store: Store) : TemplateBuilder {
  this.SelectBegin();

  store.GetStore(item.storeName).forEach(kv =&gt; {
    this.Option(kv.text);
  });

  this.SelectEnd();

  return this;
}</pre>

<p>Resulting in:</p>

<p><img border="0" height="284" src="stores1.png" width="445" /></p>

<p>That was easy enough.</p>

<p>So what&#39;s involved with persisting the actual task data and restoring it?&nbsp; Seems like the store concept can be extended to save state, and one of the states I want to support is <code>localStorage</code>.&nbsp; This also seems complicated as I&#39;m already dealing with an array of objects!&nbsp; And again, I realize why in ExtJS stores are always arrays of things, even if the store represents a singleton -- because it&#39;s easier!&nbsp; So let&#39;s refactor the <code>Store</code> class.&nbsp; First, we want something that defines the store types, like this:</p>

<pre lang="jscript">
export enum StoreType {
  Undefined,
  InMemory,
  LocalStorage,
  RestCall,
}
</pre>

<p>And then we want something that manages the configuration of the store:</p>

<pre lang="jscript">
import { StoreType } from &quot;../enums/StoreType&quot;

export class StoreConfiguration {
  storeType: StoreType;
  cached: boolean;
  data: any;

  constructor() {
    this.storeType = StoreType.Undefined;
    this.data = [];
  }
}</pre>

<p>And finally, we&#39;ll refactor the Store class so it looks like this:</p>

<pre lang="jscript">
import { StoreConfiguration } from &quot;./StoreConfiguration&quot;
import { StoreType } from &quot;../enums/StoreType&quot;
import { KeyStoreMap } from &quot;../interfaces/KeyStoreMap&quot;

export class Store {
  stores: KeyStoreMap = {};

  public CreateStore(key: string, type: StoreType) {
    this.stores[key] = new StoreConfiguration();
  }

  public AddInMemoryStore(key: string, data: object[]) {
    let store = new StoreConfiguration();
    store.storeType = StoreType.InMemory;
    store.data = data;
    this.stores[key] = store;
  }

  // Eventually will support local stores, REST calls, caching, computational stores, and using other 
  // existing objects as stores.
  public GetStoreData(key: string) {
    return this.stores[key].data;
  }
}</pre>

<p>which is used like this:</p>

<pre lang="jscript">
let store = new Store();
store.AddInMemoryStore(&quot;StatusList&quot;, taskStates);
store.CreateStore(&quot;Tasks&quot;, StoreType.LocalStorage);</pre>

<p>Next, the template that we created earlier:</p>

<pre lang="jscript">
let html = this.CreateHtmlTemplate(template, store);</pre>

<p>Needs to know what store to use for the template items, so we do this instead:</p>

<pre lang="jscript">
let html = this.CreateHtmlTemplate(template, store, &quot;Tasks&quot;);</pre>

<p>Frankly, I have no idea whether this is a good idea or not, but let&#39;s go for it for now and see how it holds up.</p>

<p>Next we need to refactor this code <code>jQuery(&quot;#template&quot;).html(html + html + html); </code>so that we&#39;re not blindly copying the HTML template but instead we have a way of building the template so that it knows what object index in the store&#39;s data to update when the field changes.&nbsp; Dealing with decoupling sorting from the store&#39;s representation of the data will be an interesting thing to figure out.&nbsp; Later.&nbsp; More to the point, that particular line of code will probably be tossed completely when we implement loading the tasks from <code>localStorage</code>.&nbsp; For the moment, in the template builder, let&#39;s add a custom attribute <code>storeIdx</code> to our two controls:</p>

<pre lang="jscript">
this.html += &quot;&lt;input type=&#39;text&#39; placeholder=&#39;&quot; + placeholder + &quot;&#39; style=&#39;width:100%&#39; storeIdx=&#39;{idx}&#39;&gt;&quot;;</pre>

<p>and:</p>

<pre lang="jscript">
this.html += &quot;&lt;select style=&#39;width:100%; height:21px&#39; storeIdx=&#39;{idx}&#39;&gt;&quot;;</pre>

<p>And now we do this:</p>

<pre lang="jscript">
let html = this.CreateHtmlTemplate(template, store, &quot;Tasks&quot;);
let task1 = this.SetStoreIndex(html, 0);
let task2 = this.SetStoreIndex(html, 1);
let task3 = this.SetStoreIndex(html, 2);
jQuery(&quot;#template&quot;).html(task1 + task2 + task3);</pre>

<p>with a little help from:</p>

<pre lang="jscript">
private SetStoreIndex(html: string, idx: number) : string {
  // a &quot;replace all&quot; function.
  let newHtml = html.split(&quot;{idx}&quot;).join(idx.toString());

  return newHtml;
}</pre>

<p>and lo-and-behold, we have indices now to the store, for example:</p>

<p><img border="0" height="51" src="stores2.png" width="503" /></p>

<p>Sigh.&nbsp; Note that the resulting HTML has the <code>storeIdx</code> attribute as all lowercase.&nbsp; This seems to be a jQuery thing that I&#39;ll investigate later.&nbsp; Next, we need to create <code>onchange</code> handlers for updating the store when the value changes.&nbsp; This must be done with &quot;late binding&quot; because the HTML is created dynamically from a template.&nbsp; Again I see why ExtJS ends up assigning arbitrary ID&#39;s to elements -- how do we identify the element to which to bind the <code>onchange</code> handler?&nbsp; Personally I prefer using a separate attribute to uniquely identify the binding point, and probably a GUID for the attribute value.&nbsp; Who knows what that will do to performance if there&#39;s hundreds of elements that must be bound, but honestly, I&#39;m not going to worry about that!</p>

<p>It&#39;s 10:30 PM, I&#39;m calling it a night!</p>

<h2><a name="6">Day 4 - Late Binding</a></h2>

<p>So here we are with the task of implementing late binding.&nbsp; First, a couple refactorings to the template builder to set up the <code>bindGuid</code> attribute with a unique identifier which we&#39;ll use to determine the binding, again using the <code>input</code> and <code>select</code> elements as examples:</p>

<pre lang="jscript">
public TextInput(item: Item, entityStore: StoreConfiguration) : TemplateBuilder {
  let placeholder = item.field;
  let guid = Guid.NewGuid();
  this.html += &quot;&lt;input type=&#39;text&#39; placeholder=&#39;&quot; + placeholder + &quot;&#39; style=&#39;width:100%&#39; storeIdx=&#39;{idx}&#39; bindGuid=&#39;&quot; + guid.ToString() + &quot;&#39;&gt;&quot;;
  let el = new TemplateElement(item, guid);
  this.elements.push(el);

 return this;
}

public SelectBegin(item: Item) : TemplateBuilder {
  let guid = Guid.NewGuid();
  this.html += &quot;&lt;select style=&#39;width:100%; height:21px&#39; storeIdx=&#39;{idx}&#39; bindGuid=&#39;&quot; + guid.ToString() + &quot;&#39;&gt;&quot;;
  let el = new TemplateElement(item, guid);
  this.elements.push(el);

  return this;
}</pre>

<p>These all get put into an array:</p>

<pre lang="jscript">
elements: TemplateElement[] = [];</pre>

<p>which the binding process on the document being ready wires up:</p>

<pre lang="jscript">
jQuery(document).ready(() =&gt; {
  // Bind the onchange events.
  builder.elements.forEach(el =&gt; {
    let jels = jQuery(&quot;[bindGuid = &#39;&quot; + el.guid.ToString() + &quot;&#39;]&quot;);

    jels.each((_, elx) =&gt; {
      let jel = jQuery(elx);

      jel.on(&#39;change&#39;, () =&gt; {
        let recIdx = jel.attr(&quot;storeIdx&quot;);
        console.log(&quot;change for &quot; + el.guid.ToString() + &quot; at index &quot; + recIdx + &quot; value of &quot; + jel.val());
        taskStore.SetProperty(Number(recIdx), el.item.field, jel.val());
      });
    });
  });
});</pre>

<p>There&#39;s a &quot;not good&quot; piece of code in the above snippet: <code>taskStore.SetProperty</code>.&nbsp; The hard-wiring to the <code>taskStore</code> is refactored out later so the binding is not specific to just the Task store!</p>

<p>Notice here we also use the record index to qualify the record.&nbsp; We do this because with this code <code>jQuery(&quot;#template&quot;).html(task1 + task2 + task3);</code> there are multiple elements with the same GUID because we&#39;ve cloned the HTML template three times.&nbsp; Probably not ideal but I&#39;ll live with that for now.&nbsp; In the meantime, the store I&#39;ve created for the tasks:</p>

<pre lang="jscript">
let taskStore = store.CreateStore(&quot;Tasks&quot;, StoreType.LocalStorage);</pre>

<p>manages setting the property value for the record at the specified index, and creating empty records as necessary:</p>

<pre lang="jscript">
public SetProperty(idx: number, property: string, value: any): StoreConfiguration {
  // Create additional records as necessary:
  while (this.data.length - 1 &lt; idx) {
    this.data.push({});
  }

  this.data[idx][property] = value;
  this.UpdatePhysicalStorage(this.data[idx], property, value);

  return this;
}

private UpdatePhysicalStorage(record: any, property: string, value: string) : Store {
  switch (this.storeType) {
    case StoreType.InMemory:
      // Do nothing.
      break;

    case StoreType.RestCall:
      // Eventually send an update but we probably ought to have a PK with which to associate the change.
      break;

    case StoreType.LocalStorage:
      // Here we just update the whole structure.
      let json = JSON.stringify(this.data);
      window.localStorage.setItem(this.name, json);
      break;	
  }

  return this;
}</pre>

<p>At the moment this is implemented in the <code>StoreConfiguration</code> class.&nbsp; Seems awkward yet it&#39;s the <code>StoreConfiguration</code> class that maintains the data, whereas the <code>Store</code> class is really a &quot;store manager&quot;, so probably <code>Store</code> should be called <code>StoreManager</code> and <code>StoreConfiguration</code> should be called <code>Store</code>!&nbsp; Gotta love refactoring to make the names of things clearer.&nbsp; So from hereon, that&#39;s what they&#39;ll be called.&nbsp; Rather a PITA to do without the &quot;rename&quot; feature when working with C# code!</p>

<p>After entering some values:</p>

<p><img border="0" height="138" src="localstore2.png" width="554" /></p>

<p>we can see that these have been serialized to the local storage (inspecting local storage in Chrome):</p>

<p><img border="0" height="260" src="localstore1.png" width="795" /></p>

<p>Cool, however notice that record 0 does not have a status, as I didn&#39;t change it from the default.&nbsp; What to do about that?&nbsp; This isn&#39;t an easy problem because we have a disconnect between the number of template instances we&#39;ve created and the store data.&nbsp; So we need a mechanism to deal with that and set defaults.&nbsp; The simplest answer is to brute force that right now.&nbsp; At least it&#39;s explicit:</p>

<pre lang="jscript">
taskStore.SetProperty(0, &quot;Status&quot;, taskStates[0].text);
taskStore.SetProperty(1, &quot;Status&quot;, taskStates[0].text);
taskStore.SetProperty(2, &quot;Status&quot;, taskStates[0].text);</pre>

<p>So now the task store is initialized with defaults:</p>

<p><img border="0" height="72" src="localstore3.png" width="377" /></p>

<p>Ultimately this only pushed the problem into the &quot;ignored&quot; bucket, as it&#39;s also dependent on the order of the status array.&nbsp; But no matter, let&#39;s push on and now that we have something in the store, let&#39;s load the UI with the store data!&nbsp; We also have the question of whether the store should be updated per keypress or only when the <code>onchange</code> event fires, which occurs when the element loses focus.&nbsp; Another &quot;ignore for now&quot; issue.&nbsp; Furthermore, we have an excellent demonstration of &quot;don&#39;t implement code with side-effects!&quot; in this function:</p>

<pre lang="jscript">
public SetProperty(idx: number, property: string, value: any): Store {
  // Create additional records as necessary:
  while (this.data.length - 1 &lt; idx) {
    this.data.push({});
  }

  this.data[idx][property] = value;
  this.UpdatePhysicalStorage(this.data[idx], property, value);

  return this;
}</pre>

<p>As updating the physical storage in the case of the local storage obliterates anything we&#39;ve saved!&nbsp; I&#39;ve created a bit of a conundrum -- if the records don&#39;t exist in the local storage, I want to set the defaults, but if they do exist, I don&#39;t want to set the defaults!&nbsp; So first, let&#39;s get rid of the side-effect and move the updating of the physical storage to the onchange handler:</p>

<pre lang="jscript">
jel.on(&#39;change&#39;, () =&gt; {
  let recIdx = Number(jel.attr(&quot;storeIdx&quot;));
  let field = el.item.field;
  let val = jel.val();

  console.log(&quot;change for &quot; + el.guid.ToString() + &quot; at index &quot; + recIdx + &quot; value of &quot; + jel.val());
  taskStore.SetProperty(recIdx, field, val).UpdatePhysicalStorage(recIdx, field, val);
});</pre>

<p>Next, this gets removed:</p>

<pre lang="jscript">
taskStore.SetProperty(0, &quot;Status&quot;, taskStates[0].text);
taskStore.SetProperty(1, &quot;Status&quot;, taskStates[0].text);
taskStore.SetProperty(2, &quot;Status&quot;, taskStates[0].text);</pre>

<p>and instead is replaced with the ability to set a default value if it doesn&#39;t exist, <i>after</i> the store has been loaded:</p>

<pre lang="jscript">
taskStore.Load()
  .SetDefault(0, &quot;Status&quot;, taskStates[0].text)
  .SetDefault(1, &quot;Status&quot;, taskStates[0].text)
  .SetDefault(2, &quot;Status&quot;, taskStates[0].text)
  .Save();</pre>

<p>which is implemented as:</p>

<pre lang="jscript">
public SetDefault(idx: number, property: string, value: any): Store {
  this.CreateNecessaryRecords(idx);

  if (!this.data[idx][property]) {
    this.data[idx][property] = value;
  }

  return this;
}</pre>

<p>And the <code>Save</code> function:</p>

<pre lang="jscript">
public Save(): Store {
  switch (this.storeType) {
    case StoreType.InMemory:
      // TODO: throw exception?
      break;

    case StoreType.RestCall:
      // Eventually send an update but we probably ought to have a PK with which to associate the change.
      break;

    case StoreType.LocalStorage:
      // Here we just update the whole structure.
      this.SaveToLocalStorage();
      break;
  }

  return this;
}</pre>

<p>However, this has the annoying effect of potentially making REST calls to save each record, even if nothing changed.&nbsp; Another &quot;ignore this for now&quot; issue, but we&#39;ll definitely need to implement a &quot;field dirty&quot; flag!&nbsp; For local storage, we have no choice, the entire structure must be saved, so for now we&#39;re good to go.&nbsp; When there&#39;s no local storage, we get the desired defaults:</p>

<p><img border="0" height="69" src="localstore4.png" width="376" /></p>

<p>And when there is data, it&#39;s not obliterated by refreshing the page:</p>

<p><img border="0" height="72" src="localstore5.png" width="435" /></p>

<p>Of course the UI doesn&#39;t update because we need the binding to work the other way as well!&nbsp; A brute force implementation looks like this:</p>

<pre lang="jscript">
for (let i = 0; i &lt; 3; i++) {
  for (let j = 0; j &lt; builder.elements.length; j++) {
    let tel = builder.elements[j];
    let guid = tel.guid.ToString();
    let jel = jQuery(`[bindGuid = &#39;${guid}&#39;][storeIdx = &#39;${i}&#39;]`);
    jel.val(taskStore.GetProperty(i, tel.item.field));
  }
}</pre>

<p>Oooh, notice the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">template literal</a>: <code>let jel = jQuery(`[bindGuid = &#39;${guid}&#39;][storeIdx = &#39;${i}&#39;]`);</code> -- I&#39;ll have to refactor the code and use that more often!</p>

<p>This yields on page load:</p>

<p><img border="0" height="136" src="localstore6.png" width="554" /></p>

<p>Cool, I can now create and save three tasks!&nbsp; Calling it quits for Day 4, back soon to work on reverse binding and better handling of defaults as well as getting rid of this silly &quot;3 tasks&quot; thing and making tasks more dynamic.</p>

<h2><a name="7">Day 5 - Store Callbacks</a></h2>

<p>So that brute force approach above needs to be fixed, but I don&#39;t want the store to know anything about how the records fields map to UI elements, so I think what I&#39;d like to do is provide callbacks for record and property level updates using the good ol&#39; Inversion of Control principle.&nbsp; Possibly something like this should be done for the different store types as well so the application can override behavior per store.&nbsp; Later.</p>

<p>To the Store class I&#39;ll add a couple callbacks with default &quot;do nothing&quot; handlers:</p>

<pre lang="jscript">
recordChangedCallback: (idx: number, record: any, store: Store) =&gt; void = () =&gt; { }; 
propertyChangedCallback: (idx: number, field: string, value: any, store: Store) =&gt; void = () =&gt; { };</pre>

<p>and in the <code>Load</code> function, we&#39;ll call the <code>recordChangedCallback</code> for every record loaded (probably not what we want to do in the long run!):</p>

<pre lang="jscript">
this.data.forEach((record, idx) =&gt; this.recordChangedCallback(idx, record, this));</pre>

<p>This gets wired in to the taskStore -- notice it&#39;s implemented so that it passes in the template builder, which is sort of like a view, so we can acquire all the field definitions in the &quot;view&quot; template:</p>

<pre lang="jscript">
taskStore.recordChangedCallback = (idx, record, store) =&gt; this.UpdateRecordView(builder, store, idx, record);</pre>

<p>and the handler looks a lot like the brute force approach above.</p>

<pre lang="jscript">
private UpdateRecordView(builder: TemplateBuilder, store: Store, idx: number, record: any): void {
  for (let j = 0; j &lt; builder.elements.length; j++) {
    let tel = builder.elements[j];
    let guid = tel.guid.ToString();
    let jel = jQuery(`[bindGuid = &#39;${guid}&#39;][storeIdx = &#39;${idx}&#39;]`);
    let val = store.GetProperty(idx, tel.item.field);
    jel.val(val);
  }
}</pre>

<p>This is a fairly generic approach.&nbsp; Let&#39;s do something similar for changing just a property and testing that by setting a record&#39;s property value via the store:</p>

<pre lang="jscript">
public SetProperty(idx: number, field: string, value: any): Store {
  this.CreateNecessaryRecords(idx);
  this.data[idx][field] = value;
  this.propertyChangedCallback(idx, field, value, this);  // &lt;== this got added.

  return this;
}</pre>

<p>Wired up like this:</p>

<pre lang="jscript">
taskStore.propertyChangedCallback = (idx, field, value, store) =&gt; this.UpdatePropertyView(builder, store, idx, field, value);</pre>

<p>And implemented like this:</p>

<pre lang="jscript">
private UpdatePropertyView(builder: TemplateBuilder, store: Store, idx: number, field: string, value: any): void {
  let tel = builder.elements.find(e =&gt; e.item.field == field);
  let guid = tel.guid.ToString();
  let jel = jQuery(`[bindGuid = &#39;${guid}&#39;][storeIdx = &#39;${idx}&#39;]`);
  jel.val(value);
}</pre>

<p>Now we can set a property for a record in a store and it&#39;s reflected in the UI:</p>

<pre lang="jscript">
taskStore.SetProperty(1, &quot;Task&quot;, `Random Task #${Math.floor(Math.random() * 100)}`);</pre>

<p><img border="0" height="137" src="setProperty1.png" width="499" /></p>

<p>So let&#39;s look at adding and deleting tasks.&nbsp; Some of you are either laughing or groaning because I&#39;ve backed myself into another corner with this &quot;record index&quot; concept, which makes deleting and inserting tasks a total nightmare because the <code>storeIdx</code> will go out of sync with the record it&#39;s managing.&nbsp; So it&#39;s time to throw out this whole concept in favor of a smarter way to handle records.&nbsp; At the moment I&#39;ve declared the store&#39;s data as an array of name:value pairs:</p>

<pre lang="jscript">
data: {}[] = [];</pre>

<p>but it&#39;s time for something smarter -- a way to uniquely identify a record without using a row index, and a way to get that unique identifier associated with the UI elements.&nbsp; The irony here is that a numeric index is a fine way to do this, we just need to map the index to the physical record rather than assume a 1:1 correlation.&nbsp; We also no longer need the <code>CreateNecessaryRecords</code> method but instead we create only this single stub key:value object if the &quot;index&quot; is missing in the index-record map.</p>

<p>So instead, I now have:</p>

<pre lang="jscript">
private data: RowRecordMap = {};</pre>

<p>It&#39;s private because I don&#39;t want anyone touching this structure, which is declared like this:</p>

<pre lang="jscript">
export interface RowRecordMap {
  [key: number]: {}
}</pre>

<p>The most significant refactoring involved the record change callback:</p>

<pre lang="jscript">
jQuery.each(this.data, (k, v) =&gt; this.recordChangedCallback(k, v, this));</pre>

<p>Pretty much nothing else changes because instead of the index being an array index, it&#39;s now a dictionary key and is therefore used in the same way.&nbsp; Here we assume that on an initial load, the record index (from 0 to n-1) corresponds 1:1 with the indices created by the template builder.&nbsp; One other important change is that to save to local storage, we don&#39;t want to save the key:value model, just the values, as the keys (the row index lookup) is completely arbitrary:</p>

<pre lang="jscript">
public GetRawData(): {}[] {
  return jQuery.map(this.data, value =&gt; value);
}

private SaveToLocalStorage() {
  let json = JSON.stringify(this.GetRawData());
  window.localStorage.setItem(this.storeName, json);
}</pre>

<h3><a name="8">Deleting a Task</a></h3>

<p>More refactoring!&nbsp; To make this work, each template that we&#39;re cloning needs to be wrapped in its own div so we can remove it.&nbsp; Currently the HTML looks like this:</p>

<p><img border="0" height="326" src="delete1.png" width="399" /></p>

<p>Where the red box is one template instance.&nbsp; Instead, we want this (the code change to make this work was trivial so I&#39;m not going to show it):</p>

<p><img border="0" height="211" src="delete2.png" width="403" /></p>

<p>Now let&#39;s reduce the width of the &quot;Why&quot; textbox and add a &quot;Delete&quot; button to the template definition:</p>

<pre lang="jscript">
{
  field: &quot;Why&quot;,
  line: 1,
  width: &quot;80%&quot;,			// &lt;== Changed
  control: &quot;textbox&quot;,
},
{
  text: &quot;Delete&quot;,		// &lt;== Added all this
  line: 1,
  width: &quot;20%&quot;,
  control: &quot;button&quot;,
}</pre>

<p>And adding a Button method to the TemplateBuilder:</p>

<pre lang="jscript">
public Button(item: Item): TemplateBuilder {
  let guid = Guid.NewGuid();
  this.html += `&lt;button type=&#39;button&#39; style=&#39;width:100%&#39; storeIdx=&#39;{idx}&#39; bindGuid=&#39;${guid.ToString()}&gt;${item.text}&lt;/button&gt;`;
  let el = new TemplateElement(item, guid);
  this.elements.push(el);

  return this;
}</pre>

<p>We get this:</p>

<p><img border="0" height="136" src="delete3.png" width="583" /></p>

<p>Snazzy.&nbsp; Now we have to wire up the event!&nbsp; Uh, ok, how will this work?&nbsp; Well first, we need to wire up the click event:</p>

<pre lang="jscript">
switch (el.item.control) {
  case &quot;button&quot;:
    jel.on(&#39;click&#39;, () =&gt; {
      let recIdx = Number(jel.attr(&quot;storeIdx&quot;));
      console.log(`click for ${el.guid.ToString()} at index ${recIdx}`);
    });
    break;

  case &quot;textbox&quot;:
  case &quot;combobox&quot;:
    jel.on(&#39;change&#39;, () =&gt; {
      let recIdx = Number(jel.attr(&quot;storeIdx&quot;));
      let field = el.item.field;
      let val = jel.val();

      console.log(`change for ${el.guid.ToString()} at index ${recIdx} with new value of ${jel.val()}`);
      storeManager.GetStore(el.item.associatedStoreName).SetProperty(recIdx, field, val).UpdatePhysicalStorage(recIdx, field, val);
    });
    break;
}</pre>

<p>And we can verify that it works by looking at the console log:</p>

<p><img border="0" height="79" src="delete4.png" width="507" /></p>

<h3><a name="9">Event Router</a></h3>

<p>Given that this is all constructed by metadata, we need an event router which can route events to arbitrary but predefined functions in the code.&nbsp; This should be quite flexible but only if the code supports the behaviors we need.</p>

<p>So let&#39;s add a route property to the template:</p>

<pre lang="jscript">
{
  text: &quot;Delete&quot;,
  line: 1,
  width: &quot;20%&quot;,
  control: &quot;button&quot;,
  route: &quot;DeleteRecord&quot;,
}</pre>

<p>Note that I don&#39;t call the route &quot;deleteTask&quot;, because deleting a record should be handled in a very general purpose manner.&nbsp; The event router start of very simple:</p>

<pre lang="jscript">
import { Store } from &quot;../classes/Store&quot;
import { RouteHandlerMap } from &quot;../interfaces/RouteHandlerMap&quot;

export class EventRouter {
  routes: RouteHandlerMap = {};

  public AddRoute(routeName: string, fnc: (store: Store, idx: number) =&gt; void) {
    this.routes[routeName] = fnc;
  }

  public Route(routeName: string, store: Store, idx: number): void {
    this.routes[routeName](store, idx);
  }
}</pre>

<p>The delete record handler is initialized:</p>

<pre lang="jscript">
let eventRouter = new EventRouter();
eventRouter.AddRoute(&quot;DeleteRecord&quot;, (store, idx) =&gt; store.DeleteRecord(idx));</pre>

<p>A callback and the DeleteRecord function is added to the store:</p>

<pre lang="jscript">
recordDeletedCallback: (idx: number, store: Store) =&gt; void = () =&gt; { }; 
...
public DeleteRecord(idx: number) : void {
  delete this.data[idx];
  this.recordDeletedCallback(idx, this);
}</pre>

<p>The delete record callback is initialized:</p>

<pre lang="jscript">
taskStore.recordDeletedCallback = (idx, store) =&gt; {
  this.DeleteRecordView(builder, store, idx);
  store.Save();
}</pre>

<p>The router is invoked when the button is clicked:</p>

<pre lang="jscript">
case &quot;button&quot;:
  jel.on(&#39;click&#39;, () =&gt; {
    let recIdx = Number(jel.attr(&quot;storeIdx&quot;));
    console.log(`click for ${el.guid.ToString()} at index ${recIdx}`);
    eventRouter.Route(el.item.route, storeManager.GetStore(el.item.associatedStoreName), recIdx);
  });
break;</pre>

<p>and the div wrapping the record is removed:</p>

<pre lang="jscript">
private DeleteRecordView(builder: TemplateBuilder, store: Store, idx: number): void {
  jQuery(`[templateIdx = &#39;${idx}&#39;]`).remove();
}</pre>

<p>Ignoring:</p>

<ul>
	<li>The &quot;templateIdx&quot; attribute name for now, which obviously has to be specified somehow to support more than one template entity type.</li>
	<li>That this removes the entire div as opposed to, say, clearing the fields or removing a row from a grid, this works nicely.&nbsp;</li>
	<li>That the Save call doesn&#39;t have a clue as to how to send a REST call to delete the specific record.</li>
</ul>

<p>We can mosey on along and after clicking on the delete button for second task, T2, we now see:</p>

<p><img border="0" height="99" src="delete5.png" width="555" /></p>

<p>and our local storage looks like this:</p>

<p><img border="0" height="59" src="delete6.png" width="410" /></p>

<p>Now let&#39;s refactor the load process so that the callback dynamically creates the template instances, which will be a precursor to inserting a new task.&nbsp; First, the <code>recordCreatedCallback</code> is renamed to <code>recordCreatedCallback</code>, which is a much better name!&nbsp; Then we&#39;re going to remove this prototyping code:</p>

<pre lang="jscript">
let task1 = this.SetStoreIndex(html, 0);
let task2 = this.SetStoreIndex(html, 1);
let task3 = this.SetStoreIndex(html, 2);
jQuery(&quot;#template&quot;).html(task1 + task2 + task3);</pre>

<p>because our template &quot;view&quot; is going to be created dynamically as records are loaded.&nbsp; So now the <code>CreateRecordView</code> function looks like this:</p>

<pre lang="jscript">
private CreateRecordView(builder: TemplateBuilder, store: Store, idx: number, record: {}): void {
  let html = builder.html;
  let template = this.SetStoreIndex(html, idx);
  jQuery(&quot;#template&quot;).append(template);

  for (let j = 0; j &lt; builder.elements.length; j++) {
    let tel = builder.elements[j];
    let guid = tel.guid.ToString();
    let jel = jQuery(`[bindGuid = &#39;${guid}&#39;][storeIdx = &#39;${idx}&#39;]`);
    let val = record[tel.item.field];
    jel.val(val);
  }
}</pre>

<h3><a name="10">Inserting Tasks</a></h3>

<p>And because in testing I obliterated all my tasks, I now have to implement a Create Task button!&nbsp; The events for all elements in the template will also need to be wired up every time we create a task!&nbsp; First, the HTML:</p>

<pre lang="jscript">
&lt;button type=&quot;button&quot; id=&quot;createTask&quot;&gt;Create Task&lt;/button&gt;
&lt;div id=&quot;template&quot; style=&quot;width:40%&quot;&gt;&lt;/div&gt;</pre>

<p>Then wiring up the event partly using the event router:</p>

<pre lang="jscript">
jQuery(&quot;#createTask&quot;).on(&#39;click&#39;, () =&gt; {
  let idx = eventRouter.Route(&quot;CreateRecord&quot;, taskStore, 0); // insert at position 0
  taskStore.SetDefault(idx, &quot;Status&quot;, taskStates[0].text);
  taskStore.Save();
});</pre>

<p>and the route definition:</p>

<pre lang="jscript">
eventRouter.AddRoute(&quot;CreateRecord&quot;, (store, idx) =&gt; store.CreateRecord(true));</pre>

<p>and the implementation in the store:</p>

<pre lang="jscript">
public CreateRecord(insert = false): number {
  let nextIdx = 0;

  if (this.Records() &gt; 0) {
    nextIdx = Math.max.apply(Math, Object.keys(this.data)) + 1;
  }

  this.data[nextIdx] = {};
  this.recordCreatedCallback(nextIdx, {}, insert, this);

  return nextIdx;
}</pre>

<p>Notice how we obtain a &quot;unique&quot; record &quot;index&quot;, and how we can specify whether to insert at the beginning or append to the end, not of the data records (these are order independent) but the flag gets passed on to the &quot;view&quot; that handles where the template should be created, so once again we refactor <code>CreateRecordView</code>:</p>

<pre lang="jscript">
private CreateRecordView(builder: TemplateBuilder, store: Store, idx: number, record: {}, insert: boolean): void {
  let html = builder.html;
  let template = this.SetStoreIndex(html, idx);

  if (insert) {
    jQuery(&quot;#template&quot;).prepend(template);
  } else {
    jQuery(&quot;#template&quot;).append(template);
  }

  this.BindSpecificRecord(builder, idx);

  for (let j = 0; j &lt; builder.elements.length; j++) {
    let tel = builder.elements[j];
    let guid = tel.guid.ToString();
    let jel = jQuery(`[bindGuid = &#39;${guid}&#39;][storeIdx = &#39;${idx}&#39;]`);
    let val = record[tel.item.field];
    jel.val(val);
  }
}</pre>

<p>I&#39;m not going to show you the BindSpecificRecord function because it&#39;s almost identical to the binding that occurs in the document ready event, and so all that common code needs to be refactored before I show it to you!&nbsp; One odd behavior that I&#39;m saving for the next day is that when the template is created this way, the combobox doesn&#39;t default to &quot;TODO&quot; - will have to figure out why.&nbsp; Regardless, starting from a blank slate:</p>

<p><img border="0" height="33" src="insert1.png" width="101" /></p>

<p>I created to tasks, note how they are in reverse order because tasks are <i> prepended</i> in the UI:</p>

<p><img border="0" height="119" src="insert2.png" width="552" /></p>

<p>and we can see that they are <i>appended</i> in the local storage:</p>

<p><img border="0" height="55" src="insert3.png" width="569" /></p>

<p>This of course causes a problem when the page is refreshed:</p>

<p><img border="0" height="114" src="insert4.png" width="551" /></p>

<p>The order got changed!&nbsp; Hmmm...</p>

<p>Now, from demos I&#39;ve seen of Vue and other frameworks, doing what has taken 5 days to accomplish here is probably a 30 minute exercise in Vue.&nbsp; However, the point here is that I&#39;m actually building the framework and the application together, and quite frankly, having a lot of fun doing it!&nbsp; So that&#39;s all that counts! End of Day 5, and I can finally create, edit, and delete tasks!</p>

<h2><a name="11">Day 6 - Basic Relationships</a></h2>

<p>So this is one of those &quot;rubber meets the road&quot; moments.&nbsp; I&#39;m going to add a couple relationships.&nbsp; Software is not monogamous!&nbsp; I&#39;d like to add contacts and notes that are child entities of the task.&nbsp; My &quot;tasks&quot; are usually integration level tasks (they probably should be called projects instead of tasks!), like &quot;add this credit card processor&quot;, which means that I have a bunch of people that I&#39;m talking to, and I want to be able to find them as related to the task.&nbsp; Same with notes, I want to make notes of conversations, discoveries and so forth related to the task.&nbsp; Why this will be a &quot;rubber meets the road&quot; moment is because I currently have no mechanism for identifying and relating together two entities, such as a task and a note.&nbsp; It&#39;ll also mean dealing with some hardcoded tags, like here:</p>

<pre lang="jscript">
if (insert) {
  jQuery(&quot;#template&quot;).prepend(template);
} else {
  jQuery(&quot;#template&quot;).append(template);
}</pre>

<p>The function needs to be general purpose and therefore the div associated with the entity has to be figured out, not hard-coded.&nbsp; So this makes more sense:</p>

<pre lang="jscript">
if (insert) {
  jQuery(builder.templateContainerID).prepend(template);
} else {
  jQuery(builder.templateContainerID).append(template);
}</pre>

<p>Also, the store event callbacks are general purpose, so we can do this:</p>

<pre lang="jscript">
this.AssignStoreCallbacks(taskStore, taskBuilder);
this.AssignStoreCallbacks(noteStore, noteBuilder);
...
private AssignStoreCallbacks(store: Store, builder: TemplateBuilder): void {
  store.recordCreatedCallback = (idx, record, insert, store) =&gt; this.CreateRecordView(builder, store, idx, record, insert);
  store.propertyChangedCallback = (idx, field, value, store) =&gt; this.UpdatePropertyView(builder, store, idx, field, value);
  store.recordDeletedCallback = (idx, store) =&gt; {
    this.DeleteRecordView(builder, store, idx);
    store.Save();
  }
}</pre>

<p>This also needs to be fixed:</p>

<pre lang="jscript">
private DeleteRecordView(builder: TemplateBuilder, store: Store, idx: number): void {
  jQuery(`[templateIdx = &#39;${idx}&#39;]`).remove();
}</pre>

<p>because the index number is not sufficient to determine the associated entity unless it&#39;s also qualified by the container name:</p>

<pre lang="jscript">
private DeleteRecordView(builder: TemplateBuilder, store: Store, idx: number): void {
  let path = `${builder.templateContainerID} &gt; [templateIdx=&#39;${idx}&#39;]`;
  jQuery(path).remove();
}</pre>

<p>But of course this assumes that the UI will have unique container names.&nbsp; This leads us to the HTML that defines the layout -- templates must be in containers:</p>

<pre lang="html">
&lt;div class=&quot;entitySeparator&quot;&gt;
  &lt;button type=&quot;button&quot; id=&quot;createTask&quot; class=&quot;createButton&quot;&gt;Create Task&lt;/button&gt;
  &lt;div id=&quot;taskTemplateContainer&quot; class=&quot;templateContainer&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;entitySeparator&quot;&gt;
  &lt;button type=&quot;button&quot; id=&quot;createNote&quot; class=&quot;createButton&quot;&gt;Create Note&lt;/button&gt;
  &lt;div id=&quot;noteTemplateContainer&quot; class=&quot;templateContainer&quot;&gt;&lt;/div&gt;
&lt;/div&gt;</pre>

<p>At this point, I can create tasks and notes:</p>

<p><img border="0" height="183" src="rel1.png" width="777" /></p>

<p>and they persist quite nicely in the local storage as well:</p>

<p><img border="0" height="160" src="rel2.png" width="894" /></p>

<p>To figure out next:</p>

<ol>
	<li>Some unique ID field in the record that is persisted.&nbsp; Normally this would be the primary key, but we&#39;re not saving the data to a database and I&#39;d like the unique ID to be decoupled from the database&#39;s PK, particularly if the user is working disconnected from the Internet, which we should be able to fairly easily support.</li>
	<li>Clicking on the parent (the task in our case) should bring up the specific child records.</li>
	<li>Do we have separate stores (like &quot;Task-Note&quot; and &quot;Task-Contact&quot;) for each parent-child relationship or do we create a &quot;metastore&quot; with parent-child entity names and this unique ID?&nbsp; Or do we create a hierarchical structure where, say, a task has child elements such as notes?</li>
	<li>How do we indicate to the user the selected parent that will be associated with the child entities?</li>
</ol>

<p>Regard #4, I like an unobtrusive approach like this, where the green left border indicates the record that&#39;s been selected.</p>

<p><img border="0" height="93" src="select1.png" width="209" /></p>

<p>The trick here is that we want to remove the selection only for the entity records associated with the selection:</p>

<pre lang="jscript">
private RecordSelected(builder: TemplateBuilder, recIdx: number): void {
  jQuery(builder.templateContainerID).children().removeClass(&quot;recordSelected&quot;);
  let path = `${builder.templateContainerID} &gt; [templateIdx=&#39;${recIdx}&#39;]`;
  jQuery(path).addClass(&quot;recordSelected&quot;);
}</pre>

<p>This way we can select a record for each entity type:</p>

<p><img border="0" height="361" src="select2.png" width="379" /></p>

<p>Regarding #3, a hierarchical structure is out of the question, as it potentially creates a highly denormalized dataset.&nbsp; Consider that a task (or if I want to add projects at some point, a project) may have the same contact information.&nbsp; If I update the contact, do I want find all the occurrences in an arbitrary hierarchy where that contact exists and update each and every one of them?&nbsp; What if I delete a contact because that person no longer works at that company?&nbsp; Heck no.&nbsp; And separate parent-child stores is rejected because of the number of local storage items (or database tables) that it requires.&nbsp; Particularly when it comes to database tables, the last thing I want to do is create parent-child tables on the fly.&nbsp; So a single meta-store that manages the mappings of all parent-child relationships seems most reasonable at the moment, the major consideration is the performance when the &quot;table&quot; contains potentially thousands (or magnitudes more) of relationships.&nbsp; At this point, such a scenario doesn&#39;t need to be considered.</p>

<p>Here we have our first concrete model:</p>

<pre lang="jscript">
export class ParentChildRelationshipModel {
  parent: string;
  child: string;
  parentId: number;
  childId: number;
}</pre>

<p>Notice that the parent and child ID&#39;s are numbers.&nbsp; The maximum number is 2<sup>1024</sup>, the problem though is that the <code>Number</code> type is a 64-bit floating point value, so it&#39;s not the range but the precision that is of concern.&nbsp; I&#39;m guessing that finding parent-child relationships by a number ID rather than, say, a GUID ID, will be faster and that I don&#39;t have to worry about precision too much at this point.</p>

<p>And (horrors), similar to ExtJS, we actually have a concrete <code>ParentChildStore</code> which will have a function for acquiring a unique number ID:</p>

<pre lang="jscript">
import { Store } from &quot;../classes/Store&quot;

export class ParentChildStore extends Store {
}</pre>

<p>The parent-child store is created a little bit differently:</p>

<pre lang="jscript">
let parentChildRelationshipStore = new ParentChildStore(storeManager, StoreType.LocalStorage, &quot;ParentChildRelationships&quot;);
storeManager.RegisterStore(parentChildRelationshipStore);</pre>

<p>And we can access a concrete store type using this function, note the comments:</p>

<pre lang="jscript">
public GetTypedStore&lt;T&gt;(storeName: string): T {
  // Compiler says: Conversion of type &#39;Store&#39; to type &#39;T&#39; may be a mistake because 
  // neither type sufficiently overlaps with the other. If this was intentional, 
  // convert the expression to &#39;unknown&#39; first.
  // So how do I tell it that T must extended from Store?
  return (&lt;unknown&gt;this.stores[storeName]) as T;
}</pre>

<p>In C#, I would write something like <code>GetStore&lt;T&gt;(string storeName) where T : Store</code> and the downcast to <code>T</code> would work fine, but I have no idea how to do this in TypeScript.<br />
<br />
While I need a persistable counter, like a sequence, to get the next ID, let&#39;s look at the CreateRecord function first:</p>

<pre lang="jscript">
public CreateRecord(insert = false): number {
  let nextIdx = 0;

  if (this.Records() &gt; 0) {
    nextIdx = Math.max.apply(Math, Object.keys(this.data)) + 1;
  }

  this.data[nextIdx] = {};        &lt;== THIS LINE IN PARTICULAR
  this.recordCreatedCallback(nextIdx, {}, insert, this);

  return nextIdx;
}</pre>

<p>It&#39;s the assignment of the empty object that needs to set an ID, but I don&#39;t want to code that in the store -- I prefer to have that decoupled, so I&#39;ll implement it as a call to the StoreManager which will then invoke a callback to the application, so the unique record identifier can be something that the application manages.&nbsp; We could even do a &quot;per store&quot; callback, but that&#39;s unnecessary at this point.&nbsp; So now the store calls:</p>

<pre lang="jscript">
this.data[nextIdx] = this.storeManager.GetPrimaryKey();</pre>

<p>The definition for the callback is crazy looking, in that it defaults to returning {}:</p>

<pre lang="jscript">
getPrimaryKeyCallback: () =&gt; any = () =&gt; {};</pre>

<p>and for testing, let&#39;s just implement a basic counter:</p>

<pre lang="jscript">
storeManager = new StoreManager();

// For testing:
let n = 0;
storeManager.getPrimaryKeyCallback = () =&gt; {
  return { __ID: ++n };
}</pre>

<p>and we can see that this creates the primary key key-value pair when I create a task!</p>

<p><img border="0" height="47" src="pk1.png" width="225" /></p>

<p>So this is the end of Day 6.&nbsp; I still need to persist the sequence, probably a &quot;Sequence&quot; store that allows me to define different sequences, and of course create the parent-child records and the UI behavior.&nbsp; Getting there!</p>

<h2><a name="12"> Day 7 - Sequence Store and the Parent-Child Relationship Store</a></h2>

<p>So a sequence store seems like a good idea.&nbsp; Again, this can be a concrete model and store.&nbsp; The model:</p>

<pre lang="jscript">
export class SequenceModel {
  key: string;
  n: number;

  constructor(key: string) {
    this.key = key;
    this.n = 0;
  }
}</pre>

<p>The <code>Sequence</code> store:</p>

<pre lang="jscript">
import { Store } from &quot;../classes/Store&quot;
import { SequenceModel } from &quot;../models/SequenceModel&quot;

export class SequenceStore extends Store {
  GetNext(skey: string): number {
    let n = 0;
    let recIdx = this.FindRecordOfType&lt;SequenceModel&gt;(r =&gt; r.key == skey);
    
    if (recIdx == -1) {
      recIdx = this.CreateRecord();
      this.SetProperty(recIdx, &quot;key&quot;, skey);
      this.SetProperty(recIdx, &quot;count&quot;, 0);
    }

    n = this.GetProperty(recIdx, &quot;count&quot;) + 1;
    this.SetProperty(recIdx, &quot;count&quot;, n);
    this.Save();

    return n;
  }
}</pre>

<p>and the <code>FindRecordOfType</code> function:</p>

<pre lang="jscript">
public FindRecordOfType&lt;T&gt;(where: (T) =&gt; boolean): number {
  let idx = -1;

  for (let k of Object.keys(this.data)) {
    if (where(&lt;T&gt;this.data[k])) {
      idx = parseInt(k);
      break;
    }
  }

  return idx;
}</pre>

<p>We can write a simple test:</p>

<pre lang="jscript">
let seqStore = new SequenceStore(storeManager, StoreType.LocalStorage, &quot;Sequences&quot;);
storeManager.RegisterStore(seqStore);
seqStore.Load();
let n1 = seqStore.GetNext(&quot;c1&quot;);
let n2 = seqStore.GetNext(&quot;c2&quot;);
let n3 = seqStore.GetNext(&quot;c2&quot;);</pre>

<p>and in the local storage, we see:</p>

<p><img border="0" height="62" src="seq1.png" width="330" /></p>

<p>so we can now assign sequences to each of the stores:</p>

<pre lang="jscript">
storeManager.getPrimaryKeyCallback = (storeName: string) =&gt; {
  return { __ID: seqStore.GetNext(storeName) };</pre>

<p>Except that creating the sequence results in infinite recursion, because the sequence record is trying to get it&#39;s own primary key!!!</p>

<p><img border="0" height="202" src="seq2.png" width="620" /></p>

<p>Oops.</p>

<p>The simplest way to deal with this is make the method overridable in the base class, first by refactoring the <code>CreateRecord</code> function:</p>

<pre lang="jscript">
public CreateRecord(insert = false): number {
  let nextIdx = 0;

  if (this.Records() &gt; 0) {
    nextIdx = Math.max.apply(Math, Object.keys(this.data)) + 1;
  }

  this.data[nextIdx] = this.GetPrimaryKey();
  this.recordCreatedCallback(nextIdx, {}, insert, this);

  return nextIdx;
}</pre>

<p>Defining the default behavior:</p>

<pre lang="jscript">
protected GetPrimaryKey(): {} {
  return this.storeManager.GetPrimaryKey(this.storeName);
}</pre>

<p>and overriding it in the SequenceStore:</p>

<pre lang="jscript">
protected GetPrimaryKey(): {} {
  return {};
}</pre>

<p>Problem solved!</p>

<h3><a name="13">Making the Association</a></h3>

<p>To make the association between parent and child record, we&#39;ll add a field to hold the selected record index in the store:</p>

<pre lang="jscript">
selectedRecordIndex: number = undefined; // multiple selection not allowed.</pre>

<p>And in the <code>BindElementEvents</code> function, where we call <code>RecordSelected</code>, we&#39;ll add setting this field in the store:</p>

<pre lang="jscript">
jel.on(&#39;focus&#39;, () =&gt; {
  this.RecordSelected(builder, recIdx));
  store.selectedRecordIndex = recIdx;
}</pre>

<p>In the event handler for the button responsible for create a task note:</p>

<pre lang="jscript">
jQuery(&quot;#createTaskNote&quot;).on(&#39;click&#39;, () =&gt; {
  let idx = eventRouter.Route(&quot;CreateRecord&quot;, noteStore, 0); // insert at position 0
  noteStore.Save();
});</pre>

<p>We&#39;ll add a call to add the parent-child record:</p>

<pre lang="jscript">
jQuery(&quot;#createTaskNote&quot;).on(&#39;click&#39;, () =&gt; {
  let idx = eventRouter.Route(&quot;CreateRecord&quot;, noteStore, 0); // insert at position 0
  parentChildRelationshipStore.AddRelationship(taskStore, noteStore, idx); // &lt;=== Added this
  noteStore.Save();
});</pre>

<p>With the implementation:</p>

<pre lang="jscript">
AddRelationship(parentStore: Store, childStore: Store, childRecIdx: number): void {
  let parentRecIdx = parentStore.selectedRecordIndex;

  if (parentRecIdx !== undefined) {
    let recIdx = this.CreateRecord();
    let parentID = parentStore.GetProperty(parentRecIdx, &quot;__ID&quot;);
    let childID = childStore.GetProperty(childRecIdx, &quot;__ID&quot;);
    let rel = new ParentChildRelationshipModel(parentStore.storeName, childStore.storeName, parentID, childID);
    this.SetRecord(recIdx, rel);
    this.Save();
  } else {
    // callback that parent record needs to be selected?
    // or throw an exception?
  }
}</pre>

<p>And there we have it:</p>

<p><img border="0" height="170" src="rel3.png" width="454" /></p>

<p>Now we just have to select the correct children for the selected parent.&nbsp; Having already defined a global variable (ugh) for declaring relationships:</p>

<pre lang="jscript">
var relationships : Relationship = [
  {
    parent: &quot;Tasks&quot;,
    children: [&quot;Notes&quot;]
  }
];</pre>

<p>Where Relationship is defined as:</p>

<pre lang="jscript">
export interface Relationship {
  parent: string;
  children: string[];
}</pre>

<p>We can now tie in to the same &quot;selected&quot; event handler to acquire the specific child relationships, remove any previous ones, and show just the specific ones for the selected record.&nbsp; We also don&#39;t want to go through this process every time a field in the record is selected.</p>

<pre lang="jscript">
jel.on(&#39;focus&#39;, () =&gt; {
  if (store.selectedRecordIndex != recIdx) {
    this.RecordSelected(builder, recIdx);
    store.selectedRecordIndex = recIdx;
    this.ShowChildRecords(store, recIdx, relationships);
  }
});</pre>

<p>In the <code>ParentChildStore</code>, we can define:</p>

<pre lang="jscript">
GetChildInfo(parent: string, parentId: number, child: string): ChildRecordInfo {
  let childRecs = this.FindRecordsOfType&lt;ParentChildRelationshipModel&gt;(rel =&gt; rel.parent == parent &amp;&amp; rel.parentId == parentId &amp;&amp; rel.child == child);
  let childRecIds = childRecs.map(r =&gt; r.childId);
  let childStore = this.storeManager.GetStore(child);

  // Annoying. VS2017 doesn&#39;t have an option for ECMAScript 7
  let recs = childStore.FindRecords(r =&gt; childRecIds.indexOf((&lt;any&gt;r).__ID) != -1);

  return { store: childStore, childrenIndices: recs };
}</pre>

<p>In the <code>Store</code> class, we implement:</p>

<pre lang="jscript">
public FindRecords(where: ({ }) =&gt; boolean): number[] {
  let recs = [];

  for (let k of Object.keys(this.data)) {
    if (where(this.data[k])) {
      recs.push(k);
    }
  }

  return recs;
}</pre>

<p>This returns the record indices, which we need to populate the template <code>{idx}</code> value so we know what record is being edited.</p>

<p>This lovely function has the job of finding the children and populating the templates (some refactoring occurred here, for example, mapping a store to its builder):</p>

<pre lang="jscript">
private ShowChildRecords(parentStore: Store, parentRecIdx: number, relationships: Relationship[]): void {
  let parentStoreName = parentStore.storeName;
  let parentId = parentStore.GetProperty(parentRecIdx, &quot;__ID&quot;);
  let relArray = relationships.filter(r =&gt; r.parent == parentStoreName);

  // Only one record for the parent type should exist.
  if (relArray.length == 1) {
    let rel = relArray[0];

    rel.children.forEach(child =&gt; {
      let builder = builders[child].builder;
      this.DeleteAllRecordsView(builder);
      let childRecs = parentChildRelationshipStore.GetChildInfo(parentStoreName, parentId, child);
      let childStore = childRecs.store;

      childRecs.childrenIndices.map(idx =&gt; Number(idx)).forEach(recIdx =&gt; {
        let rec = childStore.GetRecord(recIdx);
        this.CreateRecordView(builder, childStore, recIdx, rec, false);
      });
    });
  }
}</pre>

<p>And it works!&nbsp; Clicking on Task 1, where I created 2 notes:</p>

<p><img border="0" height="358" src="rel4.png" width="560" /></p>

<p>Clicking on Task 2, where I created 1 note:</p>

<p><img border="0" height="258" src="rel5.png" width="559" /></p>

<h3><a name="14">Contacts</a></h3>

<p>Now let&#39;s have fun and create another child, Contacts.</p>

<p>Update the relationship map:</p>

<pre lang="jscript">
var relationships : Relationship[] = [
  {
    parent: &quot;Tasks&quot;,
    children: [&quot;Contacts&quot;, &quot;Notes&quot;]
  }
];</pre>

<p>Update the HTML:</p>

<pre lang="html">
&lt;div class=&quot;entitySeparator&quot;&gt;
  &lt;button type=&quot;button&quot; id=&quot;createTask&quot; class=&quot;createButton&quot;&gt;Create Task&lt;/button&gt;
  &lt;div id=&quot;taskTemplateContainer&quot; class=&quot;templateContainer&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;entitySeparator&quot;&gt;
  &lt;button type=&quot;button&quot; id=&quot;createTaskContact&quot; class=&quot;createButton&quot;&gt;Create Contact&lt;/button&gt;
  &lt;div id=&quot;contactTemplateContainer&quot; class=&quot;templateContainer&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;entitySeparator&quot;&gt;
  &lt;button type=&quot;button&quot; id=&quot;createTaskNote&quot; class=&quot;createButton&quot;&gt;Create Note&lt;/button&gt;
  &lt;div id=&quot;noteTemplateContainer&quot; class=&quot;templateContainer&quot;&gt;&lt;/div&gt;
&lt;/div&gt;</pre>

<p>Create the contact template:</p>

<pre lang="jscript">
let contactTemplate = [
  { field: &quot;Name&quot;, line: 0, width: &quot;50%&quot;, control: &quot;textbox&quot; },
  { field: &quot;Email&quot;, line: 0, width: &quot;50%&quot;, control: &quot;textbox&quot; },
  { field: &quot;Comment&quot;, line: 1, width: &quot;100%&quot;, control: &quot;textbox&quot; },
  { text: &quot;Delete&quot;, line: 1, width: &quot;20%&quot;, control: &quot;button&quot;, route: &quot;DeleteRecord&quot; }
];</pre>

<p>Create the store:</p>

<pre lang="jscript">
let contactStore = storeManager.CreateStore(&quot;Contacts&quot;, StoreType.LocalStorage);</pre>

<p>Create the builder:</p>

<pre lang="jscript">
let contactBuilder = this.CreateHtmlTemplate(&quot;#contactTemplateContainer&quot;, contactTemplate, storeManager, contactStore.storeName);</pre>

<p>Assign the callbacks:</p>

<pre lang="jscript">
this.AssignStoreCallbacks(contactStore, contactBuilder);</pre>

<p>Add the relationship:</p>

<pre lang="jscript">
jQuery(&quot;#createTaskContact&quot;).on(&#39;click&#39;, () =&gt; {
  let idx = eventRouter.Route(&quot;CreateRecord&quot;, contactStore, 0); // insert at position 0
  parentChildRelationshipStore.AddRelationship(taskStore, contactStore, idx);
  contactStore.Save();
});</pre>

<p>Load the contacts but don&#39;t render them on the view (prevent the callback in other words):</p>

<pre lang="jscript">
taskStore.Load();
noteStore.Load(false);
contactStore.Load(false);</pre>

<p>And there we are: we&#39;ve just added another child entity to Tasks!</p>

<p><img border="0" height="261" src="rel6.png" width="555" /></p>

<p>Now, having gone through that exercise, with the exception of the HTML to hold the contacts and the contact template itself, all the rest of the stuff we manually did can be handled with a function call, which will be Day 8.&nbsp; We also have to deal with deleting the relationship entry when a child is deleted, and deleting all the child relationships when a parent is deleted. Goodnight!</p>

<h2><a name="15">Day 8 - Simplifying the Create View Steps</a></h2>

<p>First, let&#39;s create a function that takes all those discrete setup steps and rolls them into one call with a lot of parameters:</p>

<pre lang="jscript">
private CreateStoreViewFromTemplate(
  storeManager: StoreManager,
  storeName: string,
  storeType: StoreType,
  containerName: string,
  template: Items,
  createButtonId: string,
  updateView: boolean = true,
  parentStore: Store = undefined,
  createCallback: (idx: number, store: Store) =&gt; void = _ =&gt; { }
): Store {
  let store = storeManager.CreateStore(storeName, storeType);
  let builder = this.CreateHtmlTemplate(containerName, template, storeManager, storeName);
  this.AssignStoreCallbacks(store, builder);

  jQuery(document).ready(() =&gt; {
    if (updateView) {
      this.BindElementEvents(builder, _ =&gt; true);
    }

    jQuery(createButtonId).on(&#39;click&#39;, () =&gt; {
      let idx = eventRouter.Route(&quot;CreateRecord&quot;, store, 0); // insert at position 0
      createCallback(idx, store);

      if (parentStore) {
        parentChildRelationshipStore.AddRelationship(parentStore, store, idx);
      }

      store.Save();
    });
  });

  store.Load(updateView);

  return store;
}</pre>

<p>This &quot;simplifies&quot; the creation process to four steps:</p>

<ol>
	<li>Define the template.</li>
	<li>Define the container.</li>
	<li>Update the relationship map.</li>
	<li>Create the store view.</li>
</ol>

<p>Step 4 is now written as:</p>

<pre lang="jscript">
let taskStore = this.CreateStoreViewFromTemplate(
  storeManager, 
  &quot;Tasks&quot;, 
  StoreType.LocalStorage, 
  &quot;#taskTemplateContainer&quot;, 
  taskTemplate, 
  &quot;#createTask&quot;, 
  true, 
  undefined, 
  (idx, store) =&gt; store.SetDefault(idx, &quot;Status&quot;, taskStates[0].text));

this.CreateStoreViewFromTemplate(
  storeManager, 
  &quot;Notes&quot;, 
  StoreType.LocalStorage, 
  &quot;#noteTemplateContainer&quot;, 
  noteTemplate, 
  &quot;#createTaskNote&quot;, 
  false, 
  taskStore);

this.CreateStoreViewFromTemplate(
  storeManager, 
  &quot;Contacts&quot;, 
  StoreType.LocalStorage, 
  &quot;#contactTemplateContainer&quot;, 
  contactTemplate, 
  &quot;#createTaskContact&quot;, 
  false, 
  taskStore);</pre>

<p>OK, a lot of parameters, but it&#39;s a highly repeatable pattern.</p>

<p>Next, we want to delete any relationships.&nbsp; The relationship needs to be deleted before the record is deleted because we need access to the <code>__ID</code> field, so we have to reverse the way the callback is handled in the Store to:</p>

<pre lang="jscript">
public DeleteRecord(idx: number) : void {
  this.recordDeletedCallback(idx, this);
  delete this.data[idx];
}</pre>

<p>which will also allow for recursively deleting the entire hierarchy of an element when the element is deleted.</p>

<p>Then, in the callback handler:</p>

<pre lang="jscript">
store.recordDeletedCallback = (idx, store) =&gt; {
  parentChildRelationshipStore.DeleteRelationship(store, idx);
  this.DeleteRecordView(builder, idx);
}</pre>

<p>But we also have to save the store now in the route handler because the callback, which was performing the save, is being called <i>before</i> the record is deleted:</p>

<pre lang="jscript">
eventRouter.AddRoute(&quot;DeleteRecord&quot;, (store, idx) =&gt; {
  store.DeleteRecord(idx);
  store.Save();
});</pre>

<p>and the implementation in the <code>ParentChildStore</code>:</p>

<pre lang="jscript">
public DeleteRelationship(store: Store, recIdx: number) {
  let storeName = store.storeName;
  let id = store.GetProperty(recIdx, &quot;__ID&quot;);
  let touchedStores : string[] = []; // So we save the store only once after this process.

  // safety check.
  if (id) {
    let parents = this.FindRecordsOfType&lt;ParentChildRelationshipModel&gt;(rel =&gt; rel.parent == storeName &amp;&amp; rel.parentId == id);
    let children = this.FindRecordsOfType&lt;ParentChildRelationshipModel&gt;(rel =&gt; rel.child == storeName &amp;&amp; rel.childId == id);

    // All children of the parent are deleted.
    parents.forEach(p =&gt; {
      this.DeleteChildrenOfParent(p, touchedStores);
    });

    // All child relationships are deleted.
    children.forEach(c =&gt; {
      let relRecIdx = this.FindRecordOfType&lt;ParentChildRelationshipModel&gt;((r: ParentChildRelationshipModel) =&gt;
      r.parent == c.parent &amp;&amp;
      r.parentId == c.parentId &amp;&amp;
      r.child == c.child &amp;&amp;
      r.childId == c.childId);
    this.DeleteRecord(relRecIdx);
    });
  } else {
    console.log(`Expected to have an __ID value in store ${storeName} record index: ${recIdx}`);
  }

  // Save all touched stores.
  touchedStores.forEach(s =&gt; this.storeManager.GetStore(s).Save());

  this.Save();
}</pre>

<p>with a helper function:</p>

<pre lang="jscript">
private DeleteChildrenOfParent(p: ParentChildRelationshipModel, touchedStores: string[]): void {
  let childStoreName = p.child;
  let childId = p.childId;
  let childStore = this.storeManager.GetStore(childStoreName);
  let recIdx = childStore.FindRecord(r =&gt; (&lt;any&gt;r).__ID == childId);

  // safety check.
  if (recIdx != -1) {
    // Recursive deletion of child&#39;s children will occur (I think - untested!)
    childStore.DeleteRecord(recIdx);

    if (touchedStores.indexOf(childStoreName) == -1) {
      touchedStores.push(childStoreName);
    }
  } else {
    console.log(`Expected to find record in store ${childStoreName} with __ID = ${childId}`);
  }

  // Delete the parent-child relationship.
  let relRecIdx = this.FindRecordOfType&lt;ParentChildRelationshipModel&gt;((r: ParentChildRelationshipModel) =&gt;
    r.parent == p.parent &amp;&amp;
    r.parentId == p.parentId &amp;&amp;
    r.child == p.child &amp;&amp;
    r.childId == childId);

  this.DeleteRecord(relRecIdx);
}</pre>

<h2><a name="16">Day 9: Bugs</a></h2>

<p>So in creating a more rich relationship model:</p>

<pre lang="jscript">
var relationships : Relationship[] = [
{
  parent: &quot;Projects&quot;,
  children: [&quot;Tasks&quot;, &quot;Contacts&quot;, &quot;Notes&quot;]
},
{
  parent: &quot;Tasks&quot;,
  children: [&quot;Notes&quot;]
}
];</pre>

<p>in which Notes are children of both Projects and Tasks, a couple bugs came up.&nbsp;</p>

<h3><a name="17">Bug: Create a Store Only Once</a></h3>

<p>First is the issue that I was creating the Notes store twice, which is fixed checking if the store exists:</p>

<pre lang="jscript">
private CreateStoreViewFromTemplate(
...
): Store {

// ?. operator. 
// Supposedly TypeScript 3.7 has it, but I can&#39;t select that version in VS2017. VS2019?
let parentStoreName = parentStore &amp;&amp; parentStore.storeName || undefined;
let builder = this.CreateHtmlTemplate(containerName, template, storeManager, storeName, parentStoreName);
let store = undefined;

if (storeManager.HasStore(storeName)) {
  store = storeManager.GetStore(storeName);
} else {
  store = storeManager.CreateStore(storeName, storeType);
  this.AssignStoreCallbacks(store, builder);
}</pre>

<h3><a name="18">Bug: Associate the Builder with the correct Parent-Child Context</a></h3>

<p>Second, the builder has to be parent-child aware so that &quot;Create Task Note&quot; uses the Task-Note builder, not the Project-Note builder.&nbsp; This was easy enough (though sort of kludgy) to fix:</p>

<pre lang="jscript">
private GetBuilderName(parentStoreName: string, childStoreName: string): string {
  return (parentStoreName || &quot;&quot;) + &quot;-&quot; + childStoreName;
}</pre>

<p>And...</p>

<pre lang="jscript">
private CreateHtmlTemplate(templateContainerID: string, template: Items, storeManager: StoreManager, storeName: string, parentStoreName: string): TemplateBuilder {
  let builder = new TemplateBuilder(templateContainerID);
  let builderName = this.GetBuilderName(parentStoreName, storeName);
  builders[builderName] = { builder, template: templateContainerID };
  ...</pre>

<h3><a name="19">Bug: Associate the CRUD Operations with the Correct Builder Context</a></h3>

<p>The third problem is more insidious, in the call to <code>AssignStoreCallbacks</code>:</p>

<pre lang="jscript">
private AssignStoreCallbacks(store: Store, builder: TemplateBuilder): void {
  store.recordCreatedCallback = (idx, record, insert, store) =&gt; this.CreateRecordView(builder, store, idx, insert);
  store.propertyChangedCallback = (idx, field, value, store) =&gt; this.UpdatePropertyView(builder, store, idx, field, value);
  store.recordDeletedCallback = (idx, store) =&gt; {
    parentChildRelationshipStore.DeleteRelationship(store, idx);
    this.DeleteRecordView(builder, idx);
  }
}</pre>

<p>The problem here is that the builder is the one associated with the store when the store is first created.&nbsp; The bug is that because this is the Notes store for the Project-Notes builder, adding a Task-Note adds the note to the Project-Notes instead!&nbsp; Two things need to happen:</p>

<ol>
	<li>There should only be one callback for the store.</li>
	<li>But the builder must be specific to the &quot;context&quot; of the CRUD operation.</li>
</ol>

<p>The fix for this is to pass into the store the &quot;context&quot; for the CRUD operations.&nbsp; At the moment I&#39;m just passing in the <code>TemplateBuilder</code> instance because I&#39;m too lazy to create a <code>Context</code> class and I&#39;m not sure it&#39;s needed:</p>

<p>The upshot of it is that the CRUD callbacks now get the builder context which they pass along to the handler:</p>

<pre lang="jscript">
private AssignStoreCallbacks(store: Store): void {
  store.recordCreatedCallback = (idx, record, insert, store, builder) =&gt; this.CreateRecordView(builder, store, idx, insert);
  store.propertyChangedCallback = (idx, field, value, store, builder) =&gt; this.UpdatePropertyView(builder, store, idx, field, value);
  store.recordDeletedCallback = (idx, store, builder) =&gt; {
    parentChildRelationshipStore.DeleteRelationship(store, idx);
    this.DeleteRecordView(builder, idx);
  }
}</pre>

<h3><a name="20">Two Bugs, Same Solution</a></h3>

<ul>
	<li>Grandchild Views Need to be Removed When Child List Changes</li>
	<li>Deleting a Parent Should Remove Child Template Views</li>
</ul>

<p>If I create a two projects with different tasks and task notes, where the task note is the grandchild, when I select a different project, the project children update (the project tasks) but the task notes remain on-screen, which leads to a lot of confusion.&nbsp; The function ShowChildRecords is great, but we need to remove grandchild records as the child context has changed.&nbsp; So this piece of code:</p>

<pre lang="jscript">
jel.on(&#39;focus&#39;, () =&gt; {
  if (store.selectedRecordIndex != recIdx) {
    this.RecordSelected(builder, recIdx);
    store.selectedRecordIndex = recIdx;
    this.ShowChildRecords(store, recIdx, relationships);
  }
});</pre>

<p>Gets an additional function call:</p>

<pre lang="jscript">
jel.on(&#39;focus&#39;, () =&gt; {
  if (store.selectedRecordIndex != recIdx) {
    this.RemoveChildRecordsView(store, store.selectedRecordIndex);
    this.RecordSelected(builder, recIdx);
    store.selectedRecordIndex = recIdx;
    this.ShowChildRecords(store, recIdx, relationships);
  }
});</pre>

<p>which is implemented as:</p>

<pre lang="jscript">
// Recursively remove all child view records.
private RemoveChildRecordsView(store: Store, recIdx: number): void {
  let storeName = store.storeName;
  let id = store.GetProperty(recIdx, &quot;__ID&quot;);
  let rels = relationships.filter(r =&gt; r.parent == storeName);

  if (rels.length == 1) {
    let childEntities = rels[0].children;

    childEntities.forEach(childEntity =&gt; {
      if (storeManager.HasStore(childEntity)) {
        var info = parentChildRelationshipStore.GetChildInfo(storeName, id, childEntity);
        info.childrenIndices.forEach(childRecIdx =&gt; {
          let builderName = this.GetBuilderName(storeName, childEntity);
          let builder = builders[builderName].builder;
          this.DeleteRecordView(builder, childRecIdx);
          this.RemoveChildRecordsView(storeManager.GetStore(childEntity), childRecIdx);
        });
      }
    });
  }
}</pre>

<h3><a name="21">Bug: The Selected Record is Parent-Child Dependent</a></h3>

<p><b>Note: the following thought process is WRONG!</b>&nbsp; I&#39;m keeping this in here because it was something I thought was wrong and only on further reflection did I realize it was not wrong.&nbsp; Unit tests would validate my belief that the writeup here is incorrect!</p>

<p>So here goes in the wrong thinking:</p>

<p>When a store is shared between two different parents, the selected record is specific to the parent-child relationship, not the store!&nbsp;</p>

<h4><a name="22">Question: Is Parent-Child Sufficient to Describe the Uniqueness and Entity?</a></h4>

<p>No.&nbsp; For example, if I have a parent-child relationship B-C, and a hierarchy of A-B-C and D-B-C, the specific context of the records in C is associated with its relationship to B&#39;s records.&nbsp; And while B&#39;s context is in relationship to A&#39;s records, the selected record for the store depends on whether the entity path is A-B-C or D-B-C.&nbsp; Please realize that &quot;A&quot; and &quot;D&quot; different <i>entity types</i>, not different records of the same entity.</p>

<p>Even the template builder name is not a 2-level parent-child relationship.&nbsp; This works so far because the relationships are all uniquely defined with two levels of hierarchy.&nbsp; But insert another top level to the hierarchy and the template builder name&#39;s relationship to the builder (and the specific <code>templateContainerID</code> with which the builder is associated) fails.</p>

<h4><a name="23">Solution</a></h4>

<p>This means that if we don&#39;t want to keep fixing up the code, we have to have a general purpose solution to the issue of identifying:</p>

<ol>
	<li>The correct builder;</li>
	<li>The selected record;</li>
</ol>

<p>as they are associated with the <i>entity type</i> hierarchy, no matter how deep.&nbsp; Keep in mind that the parent-child relationship model is still valid because it is associating relationships between parent and child entity <i> instances</i> whereas the builder and UI management is working often with the <i> entity type</i> hierarchy.</p>

<h4><a name="24">Why This is Not a Bug</a></h4>

<p>First, when we load the records of parent-child relationship, it is qualified by the parent ID, which is unique:</p>

<pre lang="jscript">
let childRecs = parentChildRelationshipStore.GetChildInfo(parentStoreName, parentId, child);</pre>

<p>and in the <code>GetChildInfo</code> function:</p>

<pre lang="jscript">
let childRecs = this.FindRecordsOfType&lt;ParentChildRelationshipModel&gt;(rel =&gt; rel.parent == parent &amp;&amp; rel.parentId == parentId &amp;&amp; rel.child == child);</pre>

<h4><a name="25">But What is a Bug is This</a></h4>

<p>In the above two items, &quot;the correct builder&quot; and &quot;the selected record&quot;, the correct builder must be determined by the <i>entity type</i> hierarchy which needs the full path to determine the template container, but the selected record is associated with the <i>instance</i> and so is not actually the issue.</p>

<p>The code identifies the appropriate builder, which includes the HTML container template name, using:</p>

<pre lang="jscript">
let builderName = this.GetBuilderName(parentStoreName, child);</pre>

<p>which is determined by:</p>

<pre lang="jscript">
private GetBuilderName(parentStoreName: string, childStoreName: string): string {
  return (parentStoreName || &quot;&quot;) + &quot;-&quot; + childStoreName;
}</pre>

<p>So here we see that the builder associated with B-C does not have enough information to determine the template container for A-B-C vs. D-B-C.&nbsp; And that&#39;s where the real bug is.&nbsp; The upshot of this is that it&#39;s very important to distinguish between <i>type</i> and <i>instance</i>.</p>

<p>This will be addressed in Day 12, The Parent-Child Template Problem.</p>

<h3><a name="26">Nicety: Focus on First Field when Adding a Record</a></h3>

<p>Trying to avoid unnecessary clicks, this:</p>

<pre lang="jscript">
private FocusOnFirstField(builder: TemplateBuilder, idx: number) {
  let tel = builder.elements[0];
  let guid = tel.guid.ToString();
  jQuery(`[bindGuid = &#39;${guid}&#39;][storeIdx = &#39;${idx}&#39;]`).focus();
}</pre>

<p>when called here:</p>

<pre lang="jscript">
store.recordCreatedCallback = (idx, record, insert, store, builder) =&gt; {
  this.CreateRecordView(builder, store, idx, insert);
  this.FocusOnFirstField(builder, idx);
};</pre>

<p>Makes life a lot nicer.</p>

<h2><a name="27">Day 10: A Few More Niceties</a></h2>

<p>So I&#39;ve also added links at the project and task level so I can reference internal and online links that are related to the project:</p>

<pre lang="jscript">
var relationships : Relationship[] = [
  {
    parent: &quot;Projects&quot;,
    children: [&quot;Tasks&quot;, &quot;Contacts&quot;, &quot;Links&quot;, &quot;Notes&quot;]
  },
  {
    parent: &quot;Tasks&quot;,
    children: [&quot;Links&quot;, &quot;Notes&quot;]
  }
];</pre>

<p>And the related HTML and template were created as well.</p>

<h3><a name="28">This is How Life Should Work</a></h3>

<p>Just now I also decided I wanted to add &quot;Title&quot; to the Contact.&nbsp; So all I did was add this line to the <code>contactTemplate</code>:</p>

<pre lang="jscript">
{ field: &quot;Title&quot;, line: 0, width: &quot;30%&quot;, control: &quot;textbox&quot; },</pre>

<p>Done.&nbsp; What didn&#39;t have to happen was that I didn&#39;t have to change some model definition of the client-side.&nbsp; And of course I didn&#39;t have to implement a DB-schema migration, and I didn&#39;t have change some EntityFramework or Linq2SQL entity model in C#.&nbsp; Frankly, when I add server-side database support, I still don&#39;t want to do any of that stuff!&nbsp; I should be able to touch one place and one place only: the template that describes what fields I want to see and where they are.&nbsp; Everything else should just figure out how to adjust.</p>

<h2><a name="29">Day 11: Colorizing Status</a></h2>

<p>This is a bit of a hack, but I want to visually indicate the status of a project and task by colorizing the dropdown:</p>

<p><img border="0" height="211" src="statuscolor1.png" width="180" /></p>

<p>This didn&#39;t take all day, it&#39;s just the time I had available.</p>

<p>Implemented by handling the <code>change</code>, <code>focus</code>, and <code>blur</code> events -- when the dropdown gets focus, it goes back to white so the entire selection list doesn&#39;t have the background color of the current status:</p>

<pre lang="jscript">
case &quot;combobox&quot;:
  jel.on(&#39;change&#39;, () =&gt; {
    // TODO: Move this very custom behavior out into a view handler
    let val = this.SetPropertyValue(builder, jel, el, recIdx);
    this.SetComboboxColor(jel, val);
  });

  // I can&#39;t find an event for when the option list is actually shown, so for now 
  // we reset the background color on focus and restore it on lose focus.
  jel.on(&#39;focus&#39;, () =&gt; {
    jel.css(&quot;background-color&quot;, &quot;white&quot;);
  });

  jel.on(&#39;blur&#39;, () =&gt; {
    let val = jel.val();
    this.SetComboboxColor(jel, val);
  });
  break;</pre>

<p>and when the record view is created:</p>

<pre lang="jscript">
private CreateRecordView(builder: TemplateBuilder, store: Store, idx: number, insert: boolean): void {
  ...
 // Hack!
  if (tel.item.control == &quot;combobox&quot;) {
    this.SetComboboxColor(jel, val);
  }
}</pre>

<h2><a name="30">Day 12 - The Parent-Child Template Problem</a></h2>

<p>So this:</p>

<pre lang="jscript">
private GetBuilderName(parentStoreName: string, childStoreName: string): string {
  return (parentStoreName || &quot;&quot;) + &quot;-&quot; + childStoreName;
}</pre>

<p>is a hack.&nbsp; The global variables are also a hack, as is storing the selected record index in the store -- it should be associated with the view controller <i>for that store</i>, not the store! Hacks should be revisited or not even implemented in the first place!&nbsp; The whole problem here is that the element events are not coupled with an object that retains information about the &quot;event trigger&quot;, if you will, and therefore determining the builder associated with the event became a hack.&nbsp; What&#39;s needed here is a container for the binder, template ID, etc., that is bound to the specific UI events for that builder - in other words, a view controller.</p>

<pre lang="jscript">
export class ViewController {
  storeManager: StoreManager;
  parentChildRelationshipStore: ParentChildStore;
  builder: TemplateBuilder;
  eventRouter: EventRouter;
  store: Store;
  childControllers: ViewController[] = [];
  selectedRecordIndex: number = -1; // multiple selection not allowed at the moment.

  constructor(storeManager: StoreManager, parentChildRelationshipStore: ParentChildStore, eventRouter: EventRouter) {
    this.storeManager = storeManager;
    this.parentChildRelationshipStore = parentChildRelationshipStore;
    this.eventRouter = eventRouter;
}</pre>

<p>Note a couple things here:</p>

<ol>
	<li>The selected record index is associated with the view controller.</li>
	<li>A view controller manages its list of child controllers.&nbsp; This ensures that in scenarious like A-B-C and D-B-C, the controllers for B and C are distinct with regards to the roots A and D.</li>
</ol>

<p>Now, when a &quot;Create...&quot; button is clicked, the view controller passes in to the store the view controller instance:</p>

<pre lang="jscript">
jQuery(createButtonId).on(&#39;click&#39;, () =&gt; {
  let idx = this.eventRouter.Route(&quot;CreateRecord&quot;, this.store, 0, this); // insert at position 0</pre>

<p>which has the correct builder and therefore template container for entity that is being created, and while the callback is created only once per store:</p>

<pre lang="jscript">
if (this.storeManager.HasStore(storeName)) {
  this.store = this.storeManager.GetStore(storeName);
} else {
  this.store = this.storeManager.CreateStore(storeName, storeType);
  this.AssignStoreCallbacks();
}</pre>

<p>passing &quot;through&quot; the view controller ensures that the correct template container is used:</p>

<pre lang="jscript">
private AssignStoreCallbacks(): void {
  this.store.recordCreatedCallback = (idx, record, insert, store, onLoad, viewController) =&gt; {

    viewController.CreateRecordView(this.store, idx, insert, onLoad);

    // Don&#39;t select the first field when called from Store.Load, as this will select the 
    // first field for every record, leaving the last record selected. Plus we&#39;re not
    // necessarily ready to load up child records yet since the necessary view controllers
    // haven&#39;t been created.
    if (!onLoad) {
      viewController.FocusOnFirstField(idx);
    }
  };

  this.store.propertyChangedCallback = (idx, field, value) =&gt; this.UpdatePropertyView(idx, field, value);
  this.store.recordDeletedCallback = (idx, store, viewController) =&gt; {
    // A store can be associated with multiple builders: A-B-C and A-D-C, where the store is C
    viewController.RemoveChildRecordsView(store, idx);
    viewController.parentChildRelationshipStore.DeleteRelationship(store, idx);
    viewController.DeleteRecordView(idx);
  }
}
</pre>

<p>Now to create the page, we do this instead:</p>

<pre lang="jscript">
let vcProjects = new ViewController(storeManager, parentChildRelationshipStore, eventRouter);
vcProjects.CreateStoreViewFromTemplate(
  &quot;Projects&quot;, 
  StoreType.LocalStorage, 
  &quot;#projectTemplateContainer&quot;, 
  projectTemplate, &quot;#createProject&quot;, 
  true, 
  undefined, 
  (idx, store) =&gt; store.SetDefault(idx, &quot;Status&quot;, projectStates[0].text));

new ViewController(storeManager, parentChildRelationshipStore, eventRouter).
  CreateStoreViewFromTemplate(
    &quot;Contacts&quot;, 
    StoreType.LocalStorage, 
    &quot;#projectContactTemplateContainer&quot;, 
    contactTemplate, 
    &quot;#createProjectContact&quot;, 
    false, 
    vcProjects);</pre>

<p>etc.&nbsp; Notice how when we create the Contacts view controller, which is a child of Projects, we pass in the parent controller, which registers the child with its parent:</p>

<pre lang="jscript">
if (parentViewController) {
  parentViewController.RegisterChildController(this);
}</pre>

<p>The child collection is used to create and remove views using the correct view controller:</p>

<pre lang="jscript">
childRecs.childrenIndices.map(idx =&gt; Number(idx)).forEach(recIdx =&gt; {
  let vc = this.childControllers.find(c =&gt; c.store.storeName == child);
  vc.CreateRecordView(childStore, recIdx, false);
});</pre>

<p>The global variables are eliminated because they are contained now in the view controller.&nbsp; If at runtime a new view controller needs to be instantiated, this would be done by the parent view controller and it can pass in singletons such as the store manager and event router, and parent-child relationship store.</p>

<h2><a name="31">Day 13 - Audit Log</a></h2>

<p>Persisting to local storage is not really a viable long-term solution.&nbsp; While it may be useful for off-line work, we need a centralized server for the obvious - so that more than one person can access the data and so that I can access the same data from different machines.&nbsp; This involves a bunch of work:</p>

<p><img border="0" height="351" src="persist1.png" width="621" /></p>

<p>(Oh look, sub-tasks!!!)</p>

<h3><a name="32">Store Persistence Inversion of Control</a></h3>

<p>So far we have only local storage persistence, so we&#39;ll wrap the functions in this class:</p>

<pre lang="jscript">
export class LocalStoragePersistence implements IStorePersistence {
  public Load(storeName: string): RowRecordMap {
    let json = window.localStorage.getItem(storeName);
    let data = {};

    if (json) {
      try {
        // Create indices that map records to a &quot;key&quot;, in this case simply the initial row number.
        let records: {}[] = JSON.parse(json);
        records.forEach((record, idx) =&gt; data[idx] = record);
      } catch (ex) {
        console.log(ex);
        // Storage is corrupt, eek, we&#39;re going to remove it!
        window.localStorage.removeItem(storeName);
      }
    }

    return data;
  }

  public Save(storeName: string, data: RowRecordMap): void {
    let rawData = jQuery.map(data, value =&gt; value);
    let json = JSON.stringify(rawData);
    window.localStorage.setItem(storeName, json);
  }

  public Update(storeName: string, data:RowRecordMap, record: {}, idx: number, property: string, value: string) : void {
    this.Save(storeName, data);
  }
}</pre>

<p>Load, save, and update are then just calls into the abstracted persistence implementation:</p>

<pre lang="jscript">
public Load(createRecordView: boolean = true, viewController: ViewController = undefined): Store {
  this.data = this.persistence.Load(this.storeName);

  if (createRecordView) {
    jQuery.each(this.data, (k, v) =&gt; this.recordCreatedCallback(k, v, false, this, true, viewController));
  }

  return this;
}

public Save(): Store {
  this.persistence.Save(this.storeName, this.data);

  return this;
}

public UpdatePhysicalStorage(idx: number, property: string, value: string): Store {
  let record = this.data[idx];
  this.persistence.Update(this.storeName, this.data, record, idx, property, value);

  return this;
}</pre>

<p><img border="0" height="163" src="persist2.png" width="617" /></p>

<p>Woohoo.</p>

<h3><a name="33">Audit Log</a></h3>

<p>Logging the CRUD operations is actually an audit log, so we might as well call it that.&nbsp; This is a concrete store backed by a concrete model:</p>

<pre lang="jscript">
export class AuditLogModel {
  storeName: string;
  action: AuditLogAction;
  recordIndex: number;
  property: string;
  value: string;

  constructor(storeName: string, action: AuditLogAction, recordIndex: number, property: string, value: string) {
    this.storeName = storeName;
    this.action = action;
    this.recordIndex = recordIndex;
    this.property = property;
    this.value = value;
  }

  // Here we override the function because we don&#39;t want to log the audit log that calls SetRecord above.
    public SetRecord(idx: number, record: {}): Store {
    this.CreateRecordIfMissing(idx);
    this.data[idx] = record;

    return this;
  }

  // If we don&#39;t override this, calling CreateRecord here causes an infinite loop if the AuditLogStore doesn&#39;t exist yet,
  // because when the audit log store asks for its next sequence number, and the store doesn&#39;t exist,
  // SequenceStore.GetNext is called which calls CreateRecord, recursing into the Log function again.
  protected GetPrimaryKey(): {} {
    return {};
  }
}</pre>

<p>where the actions are:</p>

<pre lang="jscript">
export enum AuditLogAction {
  Create,
  Update,
  Delete
}
</pre>

<p>Here&#39;s the log where I modified the project name, created a contact, then deleted the contact:</p>

<p><img border="0" height="144" src="audit1.png" width="720" /></p>

<p>Here&#39;s an example of creating a sequence for an entity (in this case &quot;Links&quot;) that doesn&#39;t exist yet:</p>

<p><img border="0" height="102" src="audit2.png" width="603" /></p>

<p>This was the result of this code change in the store regarding the function <code>SetRecord</code>, which is why it&#39;s overridden in the <code>AuditLogStore</code>.</p>

<pre lang="jscript">
public SetRecord(idx: number, record: {}): Store {
  this.CreateRecordIfMissing(idx);
  this.data[idx] = record;

  jQuery.each(record, (k, v) =&gt; this.auditLogStore.Log(this.storeName, AuditLogAction.Update, idx, k, v)); 

  return this;
}</pre>

<p>So this is where we&#39;re at now:</p>

<p><img border="0" height="286" src="persist3.png" width="617" /></p>

<h2><a name="34">Day 14 - Server-Side Persistence</a></h2>

<p>I&#39;m implementing the server in .NET Core so I can run it on non-Windows devices as it is really just a proxy for database operations.&nbsp; Plus I&#39;m not going to use EntityFramework or Linq2Sql.&nbsp; And while I considered using a NoSQL database, I wanted the flexibility to create queries on the database that include table joins, and that&#39;s sort of a PITA -- not every NoSQL database engine implements the ability and I don&#39;t really want to deal with the <code>$lookup</code> syntax in MongoDB that I wrote about <a href="https://www.codeproject.com/Articles/1077839/Working-with-MongoDBs-lookup-Aggregator"> here</a>.</p>

<h3><a name="35">Async Client-Side Calls</a></h3>

<p>But we have a bigger problem -- AJAX calls are by nature asynchronous and I&#39;ve not accounted for any asynchronous behaviors in the TypeScript application.&nbsp; If you were thinking about that while reading this article, you are probably giggling.&nbsp; So for the moment (I haven&#39;t decided if I want to make <code>Load</code> async as well), I&#39;ve modified the store&#39;s <code>Load</code> function like this:</p>

<pre lang="jscript">
public Load(createRecordView: boolean = true, viewController: ViewController = undefined): Store {
  this.persistence.Load(this.storeName).then(data =&gt; {
    this.data = data;

    if (createRecordView) {
      jQuery.each(this.data, (k, v) =&gt; this.recordCreatedCallback(k, v, false, this, true, viewController));
    }
  });

  return this;
}</pre>

<p>The signature of the function in the IStorePersistence interface has to be modified to:</p>

<pre lang="jscript">
Load(storeName: string): Promise&lt;RowRecordMap&gt;;</pre>

<p>And the <code>LocalStoragePersistence</code> class&#39; Load function now looks like this:</p>

<pre lang="jscript">
public Load(storeName: string): Promise&lt;RowRecordMap&gt; {
  let json = window.localStorage.getItem(storeName);
  let data = {};

  if (json) {
    try {
      // Create indices that map records to a &quot;key&quot;, in this case simply the initial row number.
      let records: {}[] = JSON.parse(json);
      records.forEach((record, idx) =&gt; data[idx] = record);
    } catch (ex) {
      console.log(ex);
      // Storage is corrupt, eek, we&#39;re going to remove it!
      window.localStorage.removeItem(storeName);
    }
  }

  return new Promise((resolve, reject) =&gt; resolve(data));
}</pre>

<p>All is well with the world.</p>

<p>The <code>CloudPersistence</code> class then looks like this:</p>

<pre lang="jscript">
export class CloudPersistence implements IStorePersistence {
  baseUrl: string;

  constructor(url: string) {
    this.baseUrl = url;
  }

  public async Load(storeName: string): Promise&lt;RowRecordMap&gt; {
    let records = await jQuery.ajax({ url: this.Url(&quot;Load&quot;) + `?StoreName=${storeName}` });
    let data = {};

    // Create indices that map records to a &quot;key&quot;, in this case simply the initial row number.
    records.forEach((record, idx) =&gt; data[idx] = record);

    return data;
  }

  public Save(storeName: string, data: RowRecordMap): void {
    let rawData = jQuery.map(data, value =&gt; value);
    let json = JSON.stringify(rawData);
    jQuery.ajax({ url: this.Url(&quot;Save&quot;) + `?StoreName=${storeName}`, type: &quot;POST&quot;, data: json });
  }

  private Url(path: string): string {
    return this.baseUrl + path;
  }
}</pre>

<p>The concern here is that the Save and Update functions with their asynchronous AJAX calls may be not be received in the same order they are sent.&nbsp; This code needs to be refactored to ensure that the <b>Asynchronous</b> JavasScript and XML (AJAX!) is actually performed in the correct order by queuing the requests and processing them serially, waiting for the response from the server before sending the next one.&nbsp; Another day!</p>

<h3><a name="36">Server-Side Handlers</a></h3>

<p>On the server side (I&#39;m not going to go into my server implementation at the moment) I register this route:</p>

<pre lang="jscript">
router.AddRoute&lt;LoadStore&gt;(&quot;GET&quot;, &quot;/load&quot;, Load, false);</pre>

<p>and implement a route handler that returns a dummy empty array:</p>

<pre lang="jscript">
private static IRouteResponse Load(LoadStore store)
{
  Console.WriteLine($&quot;Load store {store.StoreName}&quot;);

  return RouteResponse.OK(new string[] {});
}</pre>

<p>Somewhat ironically I also had to add:</p>

<pre lang="jscript">
context.Response.AppendHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</pre>

<p>because the TypeScript page is being served by one address (localhost with a port that Visual Studio assigns) and my server is sitting on localhost:80.&nbsp; It&#39;s interesting watching what happens without this header -- the server gets the request but the browser blocks (throws an exception) processing the response.&nbsp;&nbsp; Sigh.</p>

<h3><a name="37">Model-less SQL</a></h3>

<p>Now we get to a decision.&nbsp; Typically the database schema is created as a &quot;known schema&quot;, using some sort of model / schema synchronization, or a migrator like <a href="https://github.com/fluentmigrator/fluentmigrator">FluentMigrator</a>, or just hand-coded.&nbsp; Personally, I have come to loathe this whole approach because it usually means:</p>

<ol>
	<li>The database has a schema that requires management.</li>
	<li>The server-side has a model that requires management.</li>
	<li>The client-side has a model that also requires management.</li>
</ol>

<p>My god.&nbsp; What ever happened to the DRY (Don&#39;t Repeat Yourself) principle when it comes to schemas and models?&nbsp; So I&#39;m going to conduct an experiment.&nbsp; As you&#39;ve noticed, there is no real model of anything on the client-side except for the couple concrete types for the audit and sequence &quot;tables.&quot;&nbsp; My so-called model is actually hidden in the view templates, for example:</p>

<pre lang="jscript">
let contactTemplate = [
  { field: &quot;Name&quot;, line: 0, width: &quot;30%&quot;, control: &quot;textbox&quot; },
  { field: &quot;Email&quot;, line: 0, width: &quot;30%&quot;, control: &quot;textbox&quot; },
  { field: &quot;Title&quot;, line: 0, width: &quot;30%&quot;, control: &quot;textbox&quot; },
  { field: &quot;Comment&quot;, line: 1, width: &quot;80%&quot;, control: &quot;textbox&quot; },
  { text: &quot;Delete&quot;, line: 1, width: &quot;80px&quot;, control: &quot;button&quot;, route: &quot;DeleteRecord&quot; }
];</pre>

<p>Oh look, the template for the view specifies the fields in which the view is interested.&nbsp; In the local storage implementation, that was quite sufficient.&nbsp; This would all be fine and dandy in a SQL database if I basically had a table like this:</p>

<pre>
ID
StoreName
PropertyName
Value</pre>

<p>Rant on.&nbsp; But I don&#39;t want that -- I <i>want</i> concrete tables with concrete columns!&nbsp; So I&#39;m going to do something you are going to kick and scream about - create the tables and necessary columns on the fly, as required, so that the view templates are the &quot;master&quot; for defining the schema.&nbsp; Yes, you read that correctly.&nbsp; Just because the whole world programs in a way that duplicates the schema, code-behind model, and client-side model, doesn&#39;t mean I have to.&nbsp; Sure there&#39;s a performance hit, but we&#39;re not dealing with bulk updates here, we&#39;re dealing with asynchronous user-driven updates.&nbsp; The user is never going to notice and more importantly to me, I will never again have to write migrations or create tables and schemas or create C# classes that mirror the DB schema.&nbsp; Unless I&#39;m doing some specific business logic on the server side, in which case the C# classes can generated from the database schema.&nbsp; There was some work in F# ages ago that I encountered where the DB schema could be used to tie in Intellisense to F# objects, but sadly that has never happened in C#, and using dynamic objects has a horrid performance and no Intellisense.&nbsp; So, there is still a major disconnect in programming language support that &quot;knows&quot; the DB schema. Rant off.</p>

<p>Tomorrow.</p>

<h2><a name="38">Day 15 - Creating the Schema on the Fly</a></h2>

<p>Before getting into this, one minor detail is needed - a user ID that is associated with the AJAX calls so data can be separated by user.&nbsp; For testing, we&#39;ll use:</p>

<pre lang="jscript">
let userID = new Guid(&quot;00000000-0000-0000-0000-000000000000&quot;);
let persistence = new CloudPersistence(&quot;http://127.0.0.1/&quot;, userId);
</pre>

<p>There is no login or authentication right now, but it&#39;s useful to put this into the coding now rather than later.</p>

<p>So now our cloud persistence <code>Load</code> function looks like this:</p>

<pre lang="jscript">
public async Load(storeName: string): Promise&lt;RowRecordMap&gt; {
  let records = await jQuery.ajax({
    url: this.Url(&quot;Load&quot;) + this.AddParams({ StoreName: storeName, UserId: this.userId.ToString() }) });
  let data = {};

  // Create indices that map records to a &quot;key&quot;, in this case simply the initial row number.
  // Note how we get the record index from record.__ID!!!
  records.forEach((record, _) =&gt; data[record.__ID] = record);

  return data;
}</pre>

<h3><a name="39">Send the Audit Log</a></h3>

<p>The <code>Save</code> function sends the current state of the audit log:</p>

<pre lang="jscript">
public Save(storeName: string, data: RowRecordMap): void {
  // For cloud persistence, what we actually want to do here is send over the audit log, not the entire store contents.
  let rawData = this.auditLogStore.GetRawData();
  let json = JSON.stringify(rawData);
  jQuery.post(this.Url(&quot;Save&quot;) + this.AddParams({ UserId: this.userId.ToString() }), JSON.stringify({ auditLog: json }));
  this.auditLogStore.Clear();
}</pre>

<p>Note how the log is cleared once we have sent it!</p>

<h3><a name="40">Save the Audit Log</a></h3>

<p>A special function is required to actually send the audit log itself because it is not in the form &quot;action-property-value&quot;, it is a concrete entity:</p>

<pre lang="jscript">
public SaveAuditLog(logEntry: AuditLogModel): void {
  let json = JSON.stringify(logEntry);
  jQuery.post(this.Url(&quot;SaveLogEntry&quot;) + this.AddParams({ UserId: this.userId.ToString() }), json);
}</pre>

<h3><a name="41">Load the Current Schema</a></h3>

<p>On the server side, we load what we know about the schema:</p>

<pre lang="cs">
private static void LoadSchema()
{
  const string sqlGetTables = &quot;SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE=&#39;BASE TABLE&#39;&quot;;
  using (var conn = OpenConnection())
  {
    var dt = Query(conn, sqlGetTables);

    foreach (DataRow row in dt.Rows)
    {
      var tableName = row[&quot;TABLE_NAME&quot;].ToString();
      schema[tableName] = new List&lt;string&gt;();
      var fields = LoadTableSchema(conn, tableName);
      schema[tableName].AddRange(fields);
    }
  }
}

private static IEnumerable&lt;string&gt; LoadTableSchema(SqlConnection conn, string tableName)
{
  string sqlGetTableFields = $&quot;SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = @tableName&quot;;
  var dt = Query(conn, sqlGetTableFields, new SqlParameter[] { new SqlParameter(&quot;@tableName&quot;, tableName) });
  var fields = (dt.AsEnumerable().Select(r =&gt; r[0].ToString()));

  return fields;
}</pre>

<h3><a name="42">Create Stores (Tables) and Columns on the Fly</a></h3>

<p>Then we have create the stores on the fly as needed:</p>

<pre lang="cs">
private static void CheckForTable(SqlConnection conn, string storeName)
{
  if (!schema.ContainsKey(storeName))
  {
    CreateTable(conn, storeName);
    schema[storeName] = new List&lt;string&gt;();
  }
}

private static void CheckForField(SqlConnection conn, string storeName, string fieldName)
{
  if (!schema[storeName].Contains(fieldName))
  {
    CreateField(conn, storeName, fieldName);
    schema[storeName].Add(fieldName);
  }
}

private static void CreateTable(SqlConnection conn, string storeName)
{
  // __ID must be a string because in ParentChildStore.GetChildInfo, this Javascript: childRecIds.indexOf((&lt;any&gt;r).__ID)
  // Does not match on &quot;1&quot; == 1
  string sql = $&quot;CREATE TABLE [{storeName}] (ID int NOT NULL PRIMARY KEY IDENTITY(1,1), UserId UNIQUEIDENTIFIER NOT NULL, __ID nvarchar(16) NOT NULL)&quot;;
  Execute(conn, sql);
}

private static void CreateField(SqlConnection conn, string storeName, string fieldName)
{
  // Here we suffer from a loss of fidelity as we don&#39;t know the field type nor length/precision.
  string sql = $&quot;ALTER TABLE [{storeName}] ADD [{fieldName}] NVARCHAR(255) NULL&quot;;
  Execute(conn, sql);
}</pre>

<h3><a name="43">Save the Audit Log</a></h3>

<p>And finally, we process the audit log on save:</p>

<pre lang="cs">
private static IRouteResponse Save(SaveStore store)
{
  var logs = JsonConvert.DeserializeObject&lt;List&lt;AuditLog&gt;&gt;(store.AuditLog);

  using (var conn = OpenConnection())
  {
    // Evil!
    lock (schemaLocker)
    {
      UpdateSchema(conn, logs);

      // The CRUD operations have to be in the lock operation so that another request doesn&#39;t update the schema while we&#39;re updating the record.
      logs.ForEach(l =&gt; PersistTransaction(conn, l, store.UserId));
    }
  }

  return RouteResponse.OK();
}

private static void PersistTransaction(SqlConnection conn, AuditLog log, Guid userId)
{
  switch (log.Action)
  {
    case AuditLog.AuditLogAction.Create:
      CreateRecord(conn, userId, log.StoreName, log.RecordIndex);
      break;

    case AuditLog.AuditLogAction.Delete:
      DeleteRecord(conn, userId, log.StoreName, log.RecordIndex);
      break;

    case AuditLog.AuditLogAction.Update:
      UpdateRecord(conn, userId, log.StoreName, log.RecordIndex, log.Property, log.Value);
      break;
  }
}</pre>

<h3><a name="44">Update the Schema on the Fly</a></h3>

<p>Notice the call to <code>UpdateSchema</code>!&nbsp; This is where the magic happens, that if a field in the table hasn&#39;t been encountered before, we create it on the fly!</p>

<pre lang="cs">
private static void UpdateSchema(SqlConnection conn, List&lt;AuditLog&gt; logs)
{
  // Create any missing tables.
  logs.Select(l =&gt; l.StoreName).Distinct().ForEach(sn =&gt; CheckForTable(conn, sn));

  // Create any missing fields.
  foreach (var log in logs.Where(l =&gt; !String.IsNullOrEmpty(l.Property)).DistinctBy(l =&gt; l, tableFieldComparer))
  {
    CheckForField(conn, log.StoreName, log.Property);
  }
}</pre>

<p>Et Voila!</p>

<p><img border="0" height="109" src="schema1.png" width="269" /></p>

<p>At this point, I haven&#39;t entered anything for the TODO and Description fields, so the schema doesn&#39;t know they exist:</p>

<p><img border="0" height="118" src="schema2.png" width="617" /></p>

<p>After I fill in the data:</p>

<p><img border="0" height="90" src="schema3.png" width="613" /></p>

<p>The schema has been modified because these additional columns were part of the audit log!</p>

<p><img border="0" height="145" src="schema4.png" width="287" /></p>

<p>And we can see the audit log entries logged as well for the changes I just made:</p>

<p><img border="0" height="99" src="audit3.png" width="636" /></p>

<p>And all the tables that were created on the fly (except for the AuditLogStore table):</p>

<p><img border="0" height="165" src="schema5.png" width="208" /></p>

<h2><a name="45">Day 16 - More Bugs</a></h2>

<h3><a name="46">Bug in How Entity __ID is Working</a></h3>

<p>After a page refresh, I discovered that the sequencer was creating the next number (let&#39;s say we&#39;re at a count of 2) as &quot;21&quot;, then &quot;211&quot;, then &quot;2111&quot;.&nbsp; This is a problem with the fact that there is no type information, so on a page refresh, the &quot;number&quot; was coming in as a string and this line of code:</p>

<pre lang="jscript">
n = this.GetProperty(recIdx, &quot;count&quot;) + 1;</pre>

<p>ended up appending the character 1, not incrementing the count.&nbsp; As long as I didn&#39;t refresh the page in my testing, everything worked fine.&nbsp; Refresh the page and new parent-child relationships stopped working!&nbsp; The workaround, lacking type information to serialize the count as a number in JSON rather than as a string, is:</p>

<pre lang="jscript">
// Number because this field is being created in the DB as an nvarchar since we don&#39;t have field types yet!
n = Number(this.GetProperty(recIdx, &quot;count&quot;)) + 1;</pre>

<p>The next problem was that the audit log wasn&#39;t passing the correct client-side &quot;primary key&quot; (the <code>__ID</code> field), which occurred after deleting records.&nbsp; This code:</p>

<pre lang="jscript">
public Log(storeName: string, action: AuditLogAction, recordIndex: number, property?: string, value?: any): void {
  let recIdx = this.InternalCreateRecord(); // no audit log for the audit log!
  let log = new AuditLogModel(storeName, action, recIdx, property, value);</pre>

<p>worked fine as long as the record index (the indexer into the store&#39;s data) was in sync with the sequence counter.&nbsp; When they became out of sync, after deleting records and doing a page refresh, again the new entities being created were saved with an <code>__ID</code> starting at 1 again!&nbsp; The sequence count was ignored.&nbsp; The fix was to get the client-side <code>__ID</code>, as this is the primary key to the record on the server, which is <b>not</b> the primary key if the table:</p>

<pre lang="jscript">
public Log(storeName: string, action: AuditLogAction, recordIndex: number, property?: string, value?: any): void {
  let recIdx = this.InternalCreateRecord(); // no audit log for the audit log!
  let id = this.storeManager.GetStore(storeName).GetProperty(recordIndex, &quot;__ID&quot;);
  let log = new AuditLogModel(storeName, action, id, property, value);</pre>

<p>After making that change, persisting changes to the sequencer stopped working because it didn&#39;t even have an <code>__ID</code>, so my thinking was wrong there -- it definitely needs and <code>__ID</code> so that the <code>SetRecord</code> function works and after creating a relationship, the appropriate fields in the parent-child store get updated correctly:</p>

<pre lang="jscript">
public SetRecord(idx: number, record: {}): Store {
  this.CreateRecordIfMissing(idx);
  this.data[idx] = record;
  jQuery.each(record, (k, v) =&gt; this.auditLogStore.Log(this.storeName, AuditLogAction.Update, idx, k, v));

  return this;
}</pre>

<p>The fix involved changing this override in the <code>SequenceStore</code>:</p>

<pre lang="jscript">
protected GetPrimaryKey(): {} {
  return {};
}</pre>

<p>to this:</p>

<pre lang="jscript">
// Sequence store has to override this function so that we don&#39;t recursively call GetNext
// when CreateRecord is called above. We need __ID so the server knows what record to operate on.
protected GetNextPrimaryKey(): {} {
  let id = Object.keys(this.data).length;
  return { __ID: id };
}</pre>

<p>Good grief.&nbsp; That was not amusing.</p>

<p>Revisiting this mess:</p>

<pre lang="cs">
private static void CreateTable(SqlConnection conn, string storeName)
{
  // __ID must be a string because in ParentChildStore.GetChildInfo, this Javascript: childRecIds.indexOf((&lt;any&gt;r).__ID)
  // Does not match on &quot;1&quot; == 1
  string sql = $&quot;CREATE TABLE [{storeName}] (ID int NOT NULL PRIMARY KEY IDENTITY(1,1), UserId UNIQUEIDENTIFIER NOT NULL, __ID nvarchar(16) NOT NULL)&quot;;
  Execute(conn, sql);
}</pre>

<p>It would probably behoove me to create a concrete model for the <code>ParentChildRelationships</code> store as right now it&#39;s being created on the fly and lacking type information, the <code>parentId</code> and <code>childId</code> fields are being created in nvarchar:</p>

<p><img border="0" height="163" src="schema6.png" width="269" /></p>

<p>I can certainly appreciate the need to have an actual model definition for each server-side table and client-side usage, but I really don&#39;t want to go down that route!&nbsp; However, it would actually be useful to create an index on the <code>(UserId, __ID)</code> field pair as the update and delete operations always use this pair to identify the record:</p>

<pre lang="cs">
private static void CreateTable(SqlConnection conn, string storeName)
{
  // __ID must be a string because in ParentChildStore.GetChildInfo, this Javascript: childRecIds.indexOf((&lt;any&gt;r).__ID)
  // Does not match on &quot;1&quot; == 1
  string sql = $&quot;CREATE TABLE [{storeName}] (ID int NOT NULL PRIMARY KEY IDENTITY(1,1), UserId UNIQUEIDENTIFIER NOT NULL, __ID nvarchar(16) NOT NULL)&quot;;
  Execute(conn, sql);
  string sqlIndex = $&quot;CREATE UNIQUE INDEX [{storeName}Index] ON [{storeName}] (UserId, __ID)&quot;;
  Execute(conn, sqlIndex);
}</pre>

<h3><a name="47">Forgot to Register the Common Fields Bug</a></h3>

<p>Another bug surfaced which I missed in the console log -- when creating a table, the in-memory schema on the server side wasn&#39;t updating the fields <code>UserId</code> and <code>__ID</code> after creating the table.&nbsp; The fix was straight forward, though I don&#39;t like the decoupling between the call to <code>CreateTable</code> and adding in the two fields that <code>CreateTable</code> creates:</p>

<pre lang="cs">
private static void CheckForTable(SqlConnection conn, string storeName)
{
  if (!schema.ContainsKey(storeName))
  {
    CreateTable(conn, storeName);
    schema[storeName] = new List&lt;string&gt;();
    schema[storeName].AddRange(new string[] { &quot;UserId&quot;, &quot;__ID&quot; });
  }
}</pre>

<p>I probably didn&#39;t notice this for ages because I hadn&#39;t dropped all the tables to create a clean slate in quite a while, at least until I modified the code above to create the indexes!&nbsp; Sigh.&nbsp; I really need to create unit tests.</p>

<h2>Bonus <a name="49">Day 17 - Entity Menu Bar</a></h2>
<p>Originally I wanted a side-menu bar that would determine what child entities 
were visible.&nbsp; While this still seemed like a good idea, I really wasn't 
sure how it would work.&nbsp; I did know one thing though -- the screen gets 
quite cluttered with a lot of projects and the views for the children and 
sub-children, which now includes:</p>
<ul>
	<li>Project Bugs</li>
	<li>Project Contacts</li>
	<li>Project Notes</li>
	<li>Project Links</li>
	<li>Project Tasks</li>
	<li>Task Notes</li>
	<li>Task Links</li>
	<li>Sub-Tasks</li>
</ul>
<p>Not only is the screen cluttered but it's also difficult to see what project 
is selected, and as the project list grows bigger, vertical scrolling will take 
place which is an added annoyance to seeing the children of a project and 
potentially their grandchildren, etc.&nbsp; What I needed was a way to focus on 
a specific project and then de-focus when switching projects.&nbsp; And I wanted 
it to be easy to focus and de-focus the project without adding additional 
buttons like &quot;Show Project Details&quot; and &quot;Back to Project List&quot;, or some such 
silliness, especially since this would cascade for children of children, like 
&quot;Show Task Details&quot; and &quot;Back to Tasks.&quot;&nbsp; So after staring at the UI for a 
good hour in contemplation (I kid you not, though I did have an interesting 
conversation at the <a href="https://store.hawthornevalley.org/">Farm Store</a> 
during this time with a total stranger, and I was at the Farm Store because the 
winds had created an 8 hour power outage on Friday, and did you really read this 
and did you really click on the Hawthorne Valley Farm Store link?) I opted for 
the following behavior:</p>
<ul>
	<li>Clicking on any control of a specific entity's record will hide all 
	other sibling entities.&nbsp; This removes all siblings so I know exactly 
	what entity I'm working with, and workings regardless of where I am in the 
	entity hierarchy.</li>
	<li>Clicking on the first control (which I would think is almost always an 
	edit box but that remains to be seen) de-selects that entity and shows all 
	siblings again.&nbsp; (Deleting an entity will do the same thing.)</li>
	<li>Now, here's the fun part -- depending on what entities you've selected 
	in the menu bar, only those children are shown when you &quot;focus&quot; on a parent 
	entity.</li>
	<li>De-selecting the focused entity will hide child entities that have been 
	selected in the menu bar.</li>
</ul>
<p>To illustrate, here's a sample project list (really original naming here):</p>
<p><img border="0" src="focus1.png" width="556" height="248"></p>
<p>Click on an entity (such as &quot;01 P) and you see:</p>
<p><img border="0" src="focus2.png" width="576" height="80"></p>
<p>That's it.&nbsp; The siblings have been hidden.&nbsp; Click on the first 
control, in this case the edit box containing the text &quot;01 P&quot;, and it becomes 
de-selected and all the siblings are shown again.&nbsp; As stated above, this 
works anywhere in the hierarchy.</p>
<p>Now here's the entity menu bar:</p>
<p><img border="0" src="focus3.png" width="130" height="204"></p>
<p>I'll clicking on Tasks in the menu bar and, assuming &quot;01 P&quot; is selected, I 
get its tasks:</p>
<p><img border="0" src="focus4.png" width="700" height="201"></p>
<p>Now I'll also select &quot;Sub-Tasks&quot;:</p>
<p><img border="0" src="focus5.png" width="698" height="236"></p>
<p>Notice the &quot;Create Sub-Task&quot; button, which is actually a bug because I 
shouldn't be able to create a child without a parent being selected.&nbsp; But 
regardless, notice that I haven't selected a task.&nbsp; As soon as I select a 
task, its sub-tasks appear:</p>
<p><img border="0" src="focus6.png" width="705" height="235"></p>
<p>I'm finding this UI behavior quite comfortable:</p>
<ul>
	<li>I can select just the entity I want to work with.</li>
	<li>I can select just the child entities I want to see in the selected 
	entity.</li>
	<li>I can easily de-select seeing the child entities.</li>
	<li>I can easily go back to seeing the entire list of siblings.</li>
	<li>I can easily see what entities in the hierarchy I've selected to see 
	when I select the parent entity.</li>
</ul>
<p>To accomplish all this, in the HTML I added:</p>
<pre lang='html'>&lt;div class=&quot;row menuBar&quot;&gt;
  &lt;div id=&quot;menuBar&quot;&gt;
  &lt;/div&gt;
&lt;/div&gt;
  &lt;div class=&quot;row entityView&quot;&gt;
  ...etc...</pre>
<p>And in the application initialization:</p>
<pre lang='jscript'>let menuBar = [
  { displayName: &quot;Bugs&quot;, viewController: vcProjectBugs },
  { displayName: &quot;Contacts&quot;, viewController: vcProjectContacts },
  { displayName: &quot;Project Notes&quot;, viewController: vcProjectNotes },
  { displayName: &quot;Project Links&quot;, viewController: vcProjectLinks },
  { displayName: &quot;Tasks&quot;, viewController: vcProjectTasks },
  { displayName: &quot;Task Notes&quot;, viewController: vcProjectTaskNotes },
  { displayName: &quot;Task Links&quot;, viewController: vcProjectTaskLinks },
  { displayName: &quot;Sub-Tasks&quot;, viewController: vcSubtasks }
];

let menuBarView = new MenuBarViewController(menuBar, eventRouter);
menuBarView.DisplayMenuBar(&quot;#menuBar&quot;);<p>The menu bar and menu items 
are defined in TypeScript as:</p>
<pre lang='jscript'>import { MenuBarItem } from &quot;./MenuBarItem&quot;

export interface MenuBar extends Array&lt;MenuBarItem&gt; { }</pre>
<p>and:</p>
<pre lang='jscript'>import { ViewController } from &quot;../classes/ViewController&quot;

export interface MenuBarItem {
  displayName: string;
  viewController: ViewController;
  id?: string;                // used internally, never set
  selected?: boolean;         // used internally, never set
}
</pre>
<p>The more interesting part of this is how <code>MenuBarViewController</code> interacts with 
the <code>ViewController</code> -- I really should rename that to be the <code>EntityViewController</code>!&nbsp; 
Notice in the constructor a couple event routes being defined:</p>
<pre lang='jscript'>export class MenuBarViewController {
  private menuBar: MenuBar;
  private eventRouter: EventRouter;

  constructor(menuBar: MenuBar, eventRouter: EventRouter) {
    this.menuBar = menuBar;
    this.eventRouter = eventRouter;

    this.eventRouter.AddRoute(&quot;MenuBarShowSections&quot;, (_, __, vc:ViewController) =&gt; this.ShowSections(vc));
    this.eventRouter.AddRoute(&quot;MenuBarHideSections&quot;, (_, __, vc: ViewController) =&gt; this.HideSections(vc));
}
</pre>
<p>The two key handlers are:</p>
<pre lang='jscript'>private ShowSections(vc: ViewController): void {
  vc.childControllers.forEach(vcChild =&gt; {
    this.menuBar.forEach(item =&gt; {
      if (item.selected &amp;&amp; vcChild == item.viewController) {
        item.viewController.ShowView();
      }
    });

    this.ShowSections(vcChild);
  });
}

private HideSections(vc: ViewController): void {
  vc.childControllers.forEach(vcChild =&gt; {
    this.menuBar.forEach(item =&gt; {
      if (item.selected &amp;&amp; vcChild == item.viewController) {
        item.viewController.HideView();
      }
    });

    this.HideSections(vcChild);
  });
}
</pre>
<p>Now, in the entity view controller, I changed <code>jel.on('focus', (e) =&gt;</code> { 
to: <code>jel.on('click', (e) =&gt;</code> for when the user focuses/clicks on an entity's control.&nbsp; 
Clicking on an entity's control has the added behavior now of showing and hiding 
siblings as well as child entities based on the menu bar selection:</p>
<pre lang='jscript'>if (this.selectedRecordIndex != recIdx) {
  this.RemoveChildRecordsView(this.store, this.selectedRecordIndex);
  this.RecordSelected(recIdx);
  this.selectedRecordIndex = recIdx;
  this.ShowChildRecords(this.store, recIdx);

  this.HideSiblingsOf(templateContainer);
  // Show selected child containers as selected by the menubar
  this.eventRouter.Route(&quot;MenuBarShowSections&quot;, undefined, undefined, this);
} else {
  let firstElement = jQuery(e.currentTarget).parent()[0] == jQuery(e.currentTarget).parent().parent().children()[0];

  if (firstElement) {
    // If user clicks on the first element of selected record,
    // the deselect the record, show all siblings, and hide all child records.
    this.ShowSiblingsOf(templateContainer);
    this.RemoveChildRecordsView(this.store, this.selectedRecordIndex);
    this.RecordUnselected(recIdx);
    this.selectedRecordIndex = -1;
    // Hide selected child containers as selected by the menubar
    this.eventRouter.Route(&quot;MenuBarHideSections&quot;, undefined, undefined, this);
  }
}</pre>
<p>And that was it!</p>
<h2><a name="50">Running the Application</a></h2>
<p>If you want to run the application using local storage, in AppMain.js, make 
sure the code reads:</p>
<pre lang='jscript'>let persistence = new LocalStoragePersistence();
// let persistence = new CloudPersistence(&quot;http://127.0.0.1/&quot;, userId);</pre>
<p>If you want to run the application using a database:</p>
<ol>
	<li>Create a database called <code>TaskTracker</code>.  Yeah, that's it, you don't have define any of the tables, they are created for you.</li>
	<li>In the server application, Program.cs, set up your connection string: <code>private static string connectionString = "[your connection string]";</code> </li>
	<li>Open a command window &quot;as administrator&quot; and cd to the root of the 
	server application, then type &quot;run&quot;.&nbsp; This builds .NET Core application 
	and launches the server.</li>
	<li>To exit the server, press Ctrl+C (I have a bug shutting down the 
	server!)</li>
	<li>If you need to change the IP address or port, do so in the TypeScript 
	(see above) <i>and</i> in the server application.</li>
</ol>
<p>And enable the cloud persistence:</p>
<pre lang='jscript'>// let persistence = new LocalStoragePersistence();
let persistence = new CloudPersistence(&quot;http://127.0.0.1/&quot;, userId);
</pre>
<h2><a name="48">Conclusion</a></h2>

<p>So this article is huge.&nbsp; You should probably read it one day at a time!&nbsp; And it&#39;s also crazy -- this is metadata driven, view defines the model, schema generated on the fly, bizarre approach to building an application.&nbsp; There&#39;s a lot to do still to make this more even more interesting such as storing the template view definitions and HTML in the database specific to the user, giving the user the flexibility to customize the entire presentation.&nbsp; The UI is ugly as sin, but it actually does the job quite nicely for what I wanted to accomplish -- organizing projects, tasks, contacts, links, bugs, and notes in a way that is actually useful to, well, me!&nbsp; Other serious warts exist, such as all fields are created as <code>nvarchar</code> since we don&#39;t have type information!</p>

<p>I hope you had fun reading this, maybe some of the ideas here are interesting if not jarring, and I&#39;ll expect to follow up with some more interesting features in the future, such as synchronizing the local store with the cloud store, which really is broken right now because the audit trail is cleared whenever a &quot;store save&quot; is done.&nbsp; Oops!&nbsp; Another thing I want to take a look at is the fact that I&#39;m loading all the user&#39;s &quot;store&quot; data on client startup - it would be more interesting to load only the child data relevant to the selected project.&nbsp; Basically a mechanism to say &quot;if I don&#39;t have these records, get them now.&quot;</p>

<p>Well, anyways, that&#39;s all for now folks!</p>
